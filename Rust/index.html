<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust 语法 | Technology Comes First</title><meta name="author" content="jiangshibiao"><meta name="copyright" content="jiangshibiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录了我对 Rust 语言的系统性学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust 语法">
<meta property="og:url" content="https://jiangshibiao.github.io/Rust/index.html">
<meta property="og:site_name" content="Technology Comes First">
<meta property="og:description" content="记录了我对 Rust 语言的系统性学习。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jiangshibiao.github.io/post_images/Rust.jpg">
<meta property="article:published_time" content="2022-05-04T01:56:47.000Z">
<meta property="article:modified_time" content="2024-05-25T16:00:00.000Z">
<meta property="article:author" content="jiangshibiao">
<meta property="article:tag" content="Digest">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangshibiao.github.io/post_images/Rust.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust 语法",
  "url": "https://jiangshibiao.github.io/Rust/",
  "image": "https://jiangshibiao.github.io/post_images/Rust.jpg",
  "datePublished": "2022-05-04T01:56:47.000Z",
  "dateModified": "2024-05-25T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "jiangshibiao",
      "url": "https://jiangshibiao.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/mylogo.jpg"><link rel="canonical" href="https://jiangshibiao.github.io/Rust/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust 语法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Technology Comes First" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/friendlink/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(../post_images/Rust.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Technology Comes First</span></a><a class="nav-page-title" href="/"><span class="site-name">Rust 语法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/friendlink/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Rust 语法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-05-04T01:56:47.000Z" title="Created 2022-05-04 2022-05-04T09:56:47+08:00">2022-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-25T16:00:00.000Z" title="Updated 2024-05-26 2024-05-26T00:00:00+08:00">2024-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Lang/">Lang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>60mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这篇博客我将详细介绍 Rust 这门语言。从创建本博客至此刻大更新（2024-5），我的 Rust 开发经验已是两年有余了——我认为它是互联网厂商泛工程开发中最合适的语言。根据我的体验，它至少拥有以下优点：</p>
<ul>
<li>好用的语言特性。可提高安全性的强语言类型、提高开发效率的自动类型推导、成熟的流操作等等。</li>
<li>舒适的开发环境。VSCode+RA，rust-fmt 和 rust-clippy 等工具让代码开发成为一种享受。</li>
<li>良好的异步引擎。不用基于麻烦的回调或 Webflux，像同步代码一样写异步！</li>
<li>高效。据传 Rust 和 C 的代码速度比是 1.07:1。这个特性让 Rust 能用在量化交易系统和链上系统。</li>
<li>安全。这是 Rust 被吹得最多的一点，诸如“内存绝对安全“、”只要过编译就罕有 bug”。我对这个特性的认知比较保守：至少，Rust 拥有一个强大的编译器，借用检查、生命周期等机制能有效降低内存泄漏的可能性。</li>
<li>优秀的包管理系统和良好的生态。Cargo 不能说是最强的包管理系统，但肯定是好用者之一。</li>
</ul>
<p>Rust 的缺点不多，体感最强烈的是编译速度太慢。<s>一般我敲入编译或测试的命令时就会去茶水间打水</s>。</p>
<h2 id="环境安装和资料推荐">环境安装和资料推荐</h2>
<p>Rust 的编译工具是 rustc（2024-04-09 版本 1.77.2），由工具 rustup 进行管理（2024-03-08 版本 1.27.0）。</p>
<p>rustup 按 <a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/tools/install">官网</a> 指示进行下载安装（注意 Windows 环境下没必要用默认的方式安装庞大的 Visual Studio）。安装完成后可以在 <code>~/.cargo/bin</code> 看到 rustup、rustc、cargo、rustfmt、rust-gdb 等一系列工具。</p>
<p>Rust 依赖 C 的编译环境，所以针对不同的操作系统和 C 语言依赖有 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rustc/platform-support.html">不同的版本</a>。用 <code>rustup toolchain</code> 来管理可能存在的多个版本。Linux 下自然依赖 gnu，而 Windows 推荐依赖 msvc。</p>
<p>Rust 开发环境推荐 VSCode + Rust Analyzer 插件或 Intellij-Rust，我用的是前者。</p>
<p>下面推荐一些 Rust 的教程和资料：</p>
<table>
<thead>
<tr>
<th>网址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://crates.io/">https://crates.io/</a></td>
<td>Rust 官方的包平台</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://rust.godbolt.org/">https://rust.godbolt.org/</a></td>
<td>将 rust 代码翻译为汇编的工具</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/">The Rust Progamming Language</a>（<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/">Rust 程序设计语言</a>）</td>
<td>Rust 官方教程，有中文翻译版</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://course.rs/about-book.html">Rust 语言圣经</a>（Rust Course）</td>
<td>中文社区教程，<s>突出贡献者居然是我同事</s></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a></td>
<td>带有大量代码示例的教程</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://rust-lang.github.io/async-book/">Rust Async Book</a></td>
<td>Rust 中的异步编程</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a></td>
<td>Rust 前沿特性教程，不推荐初学者</td>
</tr>
</tbody>
</table>
<p>常见的代码测试、格式化等命令参考：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> [options] [testname] [-- test-options]</span><br><span class="line">cargo <span class="built_in">test</span> -- --nocapture                          <span class="comment"># print normal messages like logs</span></span><br><span class="line">cargo <span class="built_in">test</span> functionname                            <span class="comment"># run all tests filter by name</span></span><br><span class="line">cargo <span class="built_in">test</span> --<span class="built_in">test</span> [filename] -- [functionname]     <span class="comment"># only run the specific test</span></span><br><span class="line">cargo <span class="built_in">test</span> --all-features                          <span class="comment"># activate all available features</span></span><br><span class="line"></span><br><span class="line">cargo clippy</span><br><span class="line">cargo clippy --fix --allow-dirty --allow-staged    <span class="comment"># check include modified, auto fix</span></span><br><span class="line">cargo <span class="built_in">sort</span> [path]                                  <span class="comment"># sort toml</span></span><br><span class="line">cargo +nightly <span class="built_in">fmt</span>                                 <span class="comment"># format code</span></span><br><span class="line">cargo +nightly udeps                               <span class="comment"># remove unused package</span></span><br></pre></td></tr></table></figure>
<p>附：何柱指导的一种 Windows 下防止 Rust  编译时候爆内存的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo install -f cargo-binutils</span><br><span class="line">rustup component add llvm-tools-preview</span><br><span class="line"></span><br><span class="line"><span class="comment"># in ~/.cargo/config</span></span><br><span class="line">[target.x86_64-pc-windows-msvc]</span><br><span class="line">linker = <span class="string">&quot;rust-lld.exe&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="包管理">包管理</h2>
<p>一个 Rust 项目里通常含有以下几项：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Cargo.toml</code></td>
<td>声明本项目直接依赖的三方库版本，以及一些构建配置。</td>
</tr>
<tr>
<td><code>Cargo.lock</code></td>
<td>由编译器自动生成，往往很大，记录了直接依赖和间接依赖的三方库信息。</td>
</tr>
<tr>
<td><code>src/*</code></td>
<td>源码，包括程序入口 <code>main.rs</code>，提供给外界用的 <code>lib.rs</code> 等。</td>
</tr>
<tr>
<td><code>tests/*</code></td>
<td>测试文件。一般用于集成测试，小型的功能测试可能直接附于源码内。</td>
</tr>
<tr>
<td><code>examples/*</code></td>
<td>一些典型的使用示例。</td>
</tr>
<tr>
<td><code>bench/*</code></td>
<td>用于测速。</td>
</tr>
</tbody>
</table>
<p>包（<em>package</em>）是提供一系列功能的若干个 crate。crate 分为库（<em>library crate</em>）和二进制项（<em>binary crate</em>）。<code>src/main.rs</code> 是默认的二进制项，<code>src/lib.rs</code> 是默认的库。<code>src/bin/</code> 下可添加任意多的二进制项。</p>
<p>模块（<em>mod</em>）可以对一个 crate 里的代码进行分组和嵌套。模块、函数、结构体、结构体成员等默认私有（子模块可以调用父模块内容，父模块无法调用子模块内容，模块之间可以调用），枚举成员默认公有。可以用 <code>pub</code> 关键词修饰公有，修饰后上一层父模块可调用子模块内容（如果想在更上层调用，需要继续添加 <code>pub</code> 关键词）。</p>
<p>调用模块树里的内容时，可以使用绝对路径（<code>crate::...</code>）或相对路径（用 <code>self::</code> 表示当前模块，也可以直接以同级的某个模块名开始；用 <code>super::</code> 表示父模块）。</p>
<p>用 <code>use</code> 导入（创建路径的软链接），用 <code>as</code> 重命名，用 <code>.*</code> 引入全部公有项。一般函数的导入会保留最后一层模块，而结构体直接引用到具体内容。 <code>use</code> 前也可以用 <code>pub</code> 修饰，称为重导出（<em>re-exporting</em>）。</p>
<p>可以用嵌套路径来消除大量的 <code>use</code> 行。如果涉及和子路径合并，可以使用 <code>self</code> 关键词。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>
<p><code>cargo tree</code> 可以查看已使用的 crate 的树型依赖关系。</p>
<h2 id="基本语法">基本语法</h2>
<p>Rust 支持类型推理。用 <code>let</code> 指定不可变变量，<code>let mut</code> 指定可变变量。</p>
<ul>
<li>用 <code>const</code> 修饰（全局）常量。需指明类型，没有固定的内存地址，值无法改变（不能加 <code>mut</code> 前缀）。</li>
<li>用 <code>static</code> 修饰（全局）静态变量。需指明类型，具有固定的内存地址。可以加 <code>mut</code> 前缀表示可变的静态变量，但访问和修改可变静态变量是非安全的（只能通过 <code>unsafe</code> 块），因为有多线程下的数据竞争问题。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">5u32</span>;</span><br><span class="line">y = <span class="number">6_222</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">0o77</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTS: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>Rust 支持变量遮蔽（<em>shadow</em>），遮蔽前后类型可以不同，作用域结束后遮蔽自动结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>函数参数和返回值（如果有）必须指定类型。函数定义的位置不作要求。如果没有返回值，默认返回 <code>()</code>。</p>
<p><code>if</code> 判断的表达式必须返回布尔类型，表达式无须强制套小括号。<code>if</code> 表达式返回的结果必须同类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>用 <code>loop</code>，<code>while</code> 和 <code>for</code> 来表示循环。支持 <code>continue</code> 和 <code>break</code>。<code>break</code> 后可添加返回值来构建表达式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    number -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型">基本数据类型</h2>
<p>Rust 是一种强类型（<em>strongly typed</em>）和静态类型（<em>statically typed</em>）语言。</p>
<p>Rust 的原生类型（<em>primitives type</em>）分为标量类型（<em>scalar type</em>）和复合类型（<em>compound type</em>）。</p>
<p>标量类型主要有以下四种：</p>
<ul>
<li>整型：<code>i8, i16, i32, i64, i128, isize; u8, u16, u32, u64, u128, usize</code>。字面量未声明默认是 <code>i32</code>。整型溢出（<em>integer overflow</em>）：debug 模式下报 panic 错误，release 模式下用补码包裹。</li>
<li>浮点类型：<code>f32, f64</code>。字面量未声明默认是 <code>f64</code>。与 <code>Nan</code> 交互都会变成 <code>NaN</code>，<code>NaN</code> 参与比较会 panic。</li>
<li>布尔类型：<code>bool</code>。大小为 1 字节。</li>
<li>字符类型：<code>char</code>。大小为 4 字节，Unicode 编码，用单引号表示。用 <code>b'x'</code> 表示字符 x 的 ASCII 值。</li>
</ul>
<p><strong>序列</strong>（<em>range</em>）用来生成连续的数值，默认前闭后开。如 <code>1..5</code>，<code>1..=5</code>。常用于 <code>for...in...</code>。</p>
<table>
<thead>
<tr>
<th>范围表达式</th>
<th>类型</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s..t</code></td>
<td><code>std::ops::Range</code></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s \le x &lt; t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></td>
</tr>
<tr>
<td><code>s..</code></td>
<td><code>std::ops::RangeFrom</code></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s \le x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></td>
</tr>
<tr>
<td><code>..t</code></td>
<td><code>std::ops::RangeTo</code></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">x &lt; t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></td>
</tr>
<tr>
<td><code>..</code></td>
<td><code>std::ops::RangeFull</code></td>
<td></td>
</tr>
<tr>
<td><code>s..=t</code></td>
<td><code>std::ops::RangeInclusive</code></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s \le x \le t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></td>
</tr>
<tr>
<td><code>..=t</code></td>
<td><code>syd::ops::RangeToInclusive</code></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">x \le t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></td>
</tr>
</tbody>
</table>
<p><strong>元组</strong>（<em>tuple</em>）可以将多个不同类型的值复合在一起，可以用模式匹配或 <code>.</code> 配合下标来索引。</p>
<p><strong>单元类型</strong>（<em>unit type</em>）是一种特殊的元组，只有一个值 <code>()</code>，称为单元值（<em>unit value</em>），不占用内存。如果表达式或函数不返回任何其他值，就隐式地返回单元值。如果 Map 不关心键值，也可以用 <code>()</code> 占位。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tuple</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six_point_four</span> = tuple.<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>数组</strong>（<em>array</em>）只能组合同类型的元素，长度是不可变的常量。数组内容会被分配至栈空间中。</p>
<p><strong>数组切片</strong>（<em>slice</em>）可以部分或全部地引用数组，前闭后开。用 <code>&amp;</code> 获得指向的地址，不实际拥有数据。切片相比原始数组的好处是长度确定，其本身一个胖指针（<em>fat pointer</em>），包含了地址和长度两个量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// [3, 3, 3, 3, 3]</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p><strong>never 类型</strong>（<em>never type</em>）是一个没有值的类型，表示永远不会完成计算的结果，用 <code>!</code> 标记。<code>panic!</code> 、一直循环的 loop、match 分支里的 break/return 会被视为 never 类型。never 类型可以被转化成任何类型。</p>
<p>Rust 不提供原生类型之间的隐式类型转换。可以用 <code>as</code> 进行显式转换，原生类型中只支持四种转换：整数和浮点数之间互相转换，枚举类型转成整型，布尔类型或字符类型转成整型，<code>u8</code> 转成字符类型。</p>
<h2 id="结构体和函数">结构体和函数</h2>
<p>结构体用 <code>struct</code> 定义，用 <code>.</code> 索引内容，包括具名结构体、元组（成员匿名）和单元结构体（没有任何成员）。具名结构体用花括号定义成员字段（单元结构体可以省略花括号）。结构体必须整个可变或整个不可变。</p>
<ul>
<li>具名结构体在初始化时，若赋值变量和待赋值的成员字段同名，可以简化赋值。</li>
<li>可以用类似初始化的方式将具名结构体里的字段移动出来。这种方式要求该结构体未定义 drop。</li>
<li>把结构体里某个字段的所有权转移出去后，就无法访问该字段，但仍能正常访问其他字段。</li>
<li>将 <code>..</code> 置于初始化的最后部分，来根据另一个实例创建新实例。</li>
<li>用 <code>impl</code> 块来定义结构体的专属方法。一个结构体可以定义多个 <code>impl</code> 块。用 <code>impl</code> 块定义的函数被称为关联函数（<em>associated functions</em>），用 <code>Self</code> 和 <code>self</code> 指代关联结构体和其实例。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    sign_in_count: <span class="number">2</span>,</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">User</span> &#123;sign_in_count, ..&#125; = user2;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数（<em>function</em>）用关键词 <code>fn</code> 声明，函数体是个块表达式。函数每个输入参数和返回值都要声明类型，若不声明则默认返回 <code>()</code>。同一模块下的函数名称不能相同（即使参数不同）。</p>
<p>方法（<em>method</em>）是以 <code>self</code>（包括 <code>&amp;self</code>，<code>mut self</code> 等） 作为第一个参数的关联函数。结构体实例调用结构体方法时，会根据方法的定义进行自动引用和解引用（<em>automatic referencing and dereferencing</em>）。</p>
<p>常量函数（<em>constant function</em>）用 <code>const fn</code> 标识，定义在常量上下文（<em>const context</em>）中，编译阶段就能执行：</p>
<ol>
<li>常量函数计算出的结果必须是确定的，即不能将随机数生成器编写为常量函数。</li>
<li>常量函数里不能包含 for 循环（loop 和 while 可以），也不能执行浮点数运算。</li>
</ol>
<p>函数、结构体和结构体方法都支持泛型，编译时进行单态化（<em>monomorphization</em>），即泛型不影响效率。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型">枚举类型</h2>
<p>枚举类型用 <code>enum</code> 定义，每个成员可以选择绑定一个数据类型。可以像结构体一样用 <code>impl</code> 定义方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>
<p>枚举的每一个成员都有自己的判别式（<em>discriminant</em>）。</p>
<ol>
<li>如果枚举类型的每个成员都没有绑定数据类型，可以通过 <code>Enum::Foo as isize</code> 获取判别式的数值。</li>
<li>标准库提供了 <code>std::mem::discriminant()</code> 方法来获取判别式的抽象值，其只能进行相等比较和哈希。</li>
</ol>
<p>用 <code>repr(T)</code> 指定判别式在存储时实际的整型。当显式指定 <code>repr</code> 或每个成员都没有绑定数据类型时：成员的判别式数值可以手动指定，未指定的字段标号默认是前一位标号+1（第一个是 0）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(i16)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    Foo = <span class="number">3</span>,</span><br><span class="line">    Bar,</span><br><span class="line">    L = -<span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个枚举类型的占用空间一般是 <code>size(T) + max(size(field))</code>。如果没有显式指定判别式的存储类型，Rust 编译器可能使用更小的类型或方法来实现判别式（但保证能正常转为 <code>isize</code>）。例如：</p>
<ol>
<li><code>Enum&#123;A, B&#125;</code> 默认使用一个字节，而 <code>Option&lt;T&gt;</code> 只需要 <code>size(T)</code>。</li>
<li><code>Trick&lt;T&gt;</code> 只需要等同于 usize 的空间（用 0 表示 Foo，其他值表示堆上 Box 的地址）。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the size is same as usize</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Trick</span>&lt;T&gt; &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    <span class="title function_ invoke__">Bar</span>(<span class="type">Box</span>&lt;T&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vec-和-String">Vec 和 String</h2>
<p><code>vec&lt;T&gt;</code> 是可变长数组，数据存储存储在堆上，栈上会保留 pointer, capacity 和 length 三个参数。</p>
<ul>
<li>下标索引元素时：如果 <code>T</code> 没有实现 copy trait，所有权会移动；越界时会报 panic 错误。</li>
<li>用 <code>.get()</code> 索引，可以得到 <code>Option&lt;&amp;T&gt;</code> 类型。</li>
</ul>
<p>注意获得某个下标引用的同时禁止对 vector 进行 push，因为 push 要获取整个 vector 的可变引用。</p>
<p>可以用 <code>Vec::new()</code> 新建或 <code>vec![]</code> 宏初始化构造，根据下一次使用进行类型推理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">5</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">5</span>);</span><br><span class="line">w.<span class="title function_ invoke__">resize</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以用 <code>for...in...</code> 简化对 vector 的遍历，包括不可变引用遍历和可变引用遍历。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用枚举类型来变相让 vector 支持不同类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><strong>字符串</strong>（<em>string</em>）由 UTF-8 编码，本质上是 <code>Vec&lt;u8&gt; </code> 的封装，数据保存在堆里。因为每个元素占用的字节数可能不同，字符串 <strong>不支持下标索引</strong> 以防止歧义发生。字符串和字符（Unicode）互转时会有性能开销。</p>
<ul>
<li>用 <code>.chars()</code> 返回字符串的实际字符集合；用 <code>.chars().count()</code> 统计实际字符个数，复杂度线性。</li>
<li>用 <code>.bytes()</code> 返回每一个原始字节信息；用 <code>.len()</code> 返回实际字节数，复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);           <span class="comment">// push_str 的参数是 slice，即不获取其所有权</span></span><br><span class="line">s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;2&#x27;</span>);                      <span class="comment">// push 的参数是单个字符</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">end_char</span> = s1.<span class="title function_ invoke__">pop</span>();           <span class="comment">// 删除最后一个字符并返回</span></span><br><span class="line">s1.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);                      <span class="comment">// 删除指定位置的字符，索引必须是该字符开头</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = s1 + <span class="string">&quot;233&quot;</span>;           <span class="comment">// &#x27;+&#x27; 会调用 add，会抢走左边变量的所有权</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, s2, s3);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(<span class="built_in">vec!</span>[<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>]);</span><br></pre></td></tr></table></figure>
<p><strong>字符串切片</strong>（<em>str</em>）是最原始的字符串类型，能保证内部是有效的 UTF-8 编码。</p>
<p>字符串切片通常以借用的方式（&amp;str）存在。&amp;str 和数组切片一样，是一个包含地址、长度两个量的胖指针。</p>
<p>&amp;str 可以源于对字符串执行切片操作。注意长度按原始字节来处理，切断 utf-8 编码后会 panic。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">assert!</span>(s.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;nana&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = hello.<span class="title function_ invoke__">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: &amp;<span class="type">str</span> = <span class="string">&quot;hello\n&quot;</span>;       <span class="comment">// 自动转义处理。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: &amp;<span class="type">str</span> = <span class="string">r&quot;hello\world&quot;</span>;  <span class="comment">// 原始字面量，不处理转义。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: &amp;<span class="type">str</span> = <span class="string">r#&quot;hello&quot;o&quot;#</span>;    <span class="comment">// 包含双引号的原始字面量，用 #&quot; 和 &quot;# 标识头尾。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">d</span>: &amp;<span class="type">str</span> = &amp;string[<span class="number">0</span>..<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>同时接受 <code>&amp;str</code> 和 <code>String</code> 的函数签名可以写成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">parse</span>&lt;S&gt;(s: S) <span class="keyword">where</span> S: <span class="built_in">AsRef</span>&lt;<span class="type">str</span>&gt;            <span class="comment">// 都视为 &amp;str</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">parse</span>&lt;S&gt;(s: S) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> <span class="keyword">where</span> S: <span class="built_in">Into</span>&lt;<span class="type">String</span>&gt;  <span class="comment">// 都转成 String</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/jimmychu0807/9a89355e642afad0d2aeda52e6ad2424">Vec, [u8], String, str 的相互转化</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// -- FROM: vec of chars --</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">src1</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = <span class="built_in">vec!</span>[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>];</span><br><span class="line">  <span class="comment">// to String</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">string1</span>: <span class="type">String</span> = src1.<span class="title function_ invoke__">iter</span>().collect::&lt;<span class="type">String</span>&gt;();</span><br><span class="line">  <span class="comment">// to str</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">str1</span>: &amp;<span class="type">str</span> = &amp;src1.<span class="title function_ invoke__">iter</span>().collect::&lt;<span class="type">String</span>&gt;();</span><br><span class="line">  <span class="comment">// to vec of byte</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">byte1</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = src1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|c| *c <span class="keyword">as</span> <span class="type">u8</span>).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -- FROM: vec of bytes --</span></span><br><span class="line">  <span class="comment">// b - byte, r - raw string, br - byte of raw string</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">src2</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="string">br#&quot;e&#123;&quot;ddie&quot;&#125;&quot;#</span>.<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line">  <span class="comment">// to String</span></span><br><span class="line">  <span class="comment">// from_utf8 consume the vector of bytes</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">string2</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(src2.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">  <span class="comment">// to str</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">str2</span>: &amp;<span class="type">str</span> = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;src2).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">  <span class="comment">// to vec of chars</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">char2</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = src2.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|b| *b <span class="keyword">as</span> <span class="type">char</span>).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -- FROM: String --</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">src3</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">r#&quot;o&#123;&quot;livia&quot;&#125;&quot;#</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">str3</span>: &amp;<span class="type">str</span> = &amp;src3;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">char3</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = src3.<span class="title function_ invoke__">chars</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">byte3</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = src3.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -- FROM: str --</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">src4</span>: &amp;<span class="type">str</span> = <span class="string">r#&quot;g&#123;&#x27;race&#x27;&#125;&quot;#</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">string4</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(src4);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">char4</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = src4.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">byte4</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = src4.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式匹配">模式匹配</h2>
<p>Match 是模式匹配的经典案例，允许将一个值与一系列模式进行比较，并执行对应的流程。</p>
<ul>
<li>每一种模式的处理结果的返回值必须相同。允许某个分支里使用 <code>continue/return/panic!</code> ，其返回类型会被标注成 <code>!</code>，然后被强制转化成需要的类型。</li>
<li>模式之间范围可以重叠（优先取第一个），但必须穷尽所有情况。可使用 <code>&lt;name&gt;/_</code> 表示其他情况。</li>
<li>由于编译时要确定每个模式是否非空，当模式使用序列时仅支持表达式是数值类型和字符类型。当前稳定版本的 Rust 仅支持 inclusive 的区间表达式，即必须使用 <code>a..=b</code> 、<code>..=b</code> 和 <code>a..</code> 三种形式。</li>
<li>用 <code>|</code> 表示并列；用 <code>@</code> 将模式内容绑定到变量上供分支流程里使用，如 <code>n @ 1..=12</code> 和 <code>Some(n @ 42)</code>。</li>
<li>值的表达式可以表示结构体，用花括号取其中的若干字段，用 <code>..</code> 表示忽略剩余字段。</li>
<li><strong>匹配守卫</strong>（<em>match guard</em>）应用于某个分支后，只有当额外的 <code>if</code> 条件成立才会执行对应语句。当同一句模式里匹配守卫和 | 结合时，| 前后所有的可能都会执行 if 条件。</li>
</ul>
<p><code>if let</code> 是 Match 的语法糖（没有定义 PartialEq 的 enum 也能使用），可选的 <code>else</code> 相当于 Match 里的 <code>_</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 1.65 支持了 <code>let else</code> 语法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_count_item</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">it</span> = s.<span class="title function_ invoke__">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> (<span class="title function_ invoke__">Some</span>(count_str), <span class="title function_ invoke__">Some</span>(item)) = (it.<span class="title function_ invoke__">next</span>(), it.<span class="title function_ invoke__">next</span>()) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Can&#x27;t segment count item pair: &#x27;&#123;s&#125;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>let</code>，<code>while let</code> 和 <code>for</code> 中也可以使用模式匹配来简化代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    x: (<span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = ...</span><br><span class="line"><span class="keyword">for</span> <span class="title class_">Point</span> &#123;(a, b), c&#125; <span class="keyword">in</span> foo &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">Foo</span> &#123;</span><br><span class="line">    x: (a, b),</span><br><span class="line">    y: rename_y</span><br><span class="line">&#125; = foo;</span><br></pre></td></tr></table></figure>
<p>模式的可反驳性（<em>refutability</em>）：<strong>不可反驳的</strong> 指能匹配任何传递的值，<strong>可反驳的</strong> 指会存在匹配失败。</p>
<ul>
<li>函数参数，<code>let</code> 和 <code>for</code> 只能接受不可反驳的模式，因为不匹配时是无意义的。</li>
<li><code>if let</code>、<code>while let</code> 和 <code>let else</code> 被设计成只能接受可反驳的模式。</li>
<li><code>match</code> 中最多只能有一个分支使用不可反驳模式。</li>
</ul>
<p>切片模式可以匹配固定大小的数组和动态大小的数组切片。</p>
<ul>
<li>匹配数组时，只要每个元素都是不可反驳的，切片模式就是不可反驳的。</li>
<li>匹配数组切片时，只有当模式是有标识符和后置的 <code>..</code> 构成时，才是不可反驳的。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">match</span> v[..] &#123;</span><br><span class="line">	[a, b] =&gt; (),</span><br><span class="line">	[a, b, c] =&gt; (),</span><br><span class="line">	_ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片模式内部如果用范围模式表达某个元素：</p>
<ul>
<li>和 Match 一样，当前 Rust 稳定版不允许使用 inclusive 的范围模式。</li>
<li>没有上下界的必须用括号括起来，如 <code>(a..)</code>；具有上下界的范围模式则无须括号，如 <code>a..=b</code>。</li>
</ul>
<h2 id="Option-和-Result">Option 和 Result</h2>
<p>Option 和 Result 是 Rust 内置的泛型枚举类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>Result&lt;T, E&gt;</code> 处理可恢复的错误。</p>
<ul>
<li><code>.unwrap()</code> 可以解包 <code>Result</code> 直接获得其返回值，若产生 Error 会转化成 panic。</li>
<li><code>.expect()</code> 与上述类似，只是会把 panic 错误信息替换成给出的字符串参数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数的末尾加上 <code>?</code> 后可以简单地起到错误传播的作用。即若 Result 返回值是 Ok，? 不起任何作用；若返回值是 Err，会把值做一个 <code>into()</code>  强制转换并向外传递。<code>?</code> 本质上是所有实现了 <code>try trait</code> 的类型的语法糖。最常见的实现了 <code>try trait</code> 的类型是 <code>Result&lt;Ok, Err&gt;</code>，<code>Option&lt;T&gt;</code> 和 <code>ControlFlow&lt;B, C&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当开发者遇到不可处理的错误时，Rust 会产生 panic，此时有两种处理方式可选。</p>
<ul>
<li>栈展开（<em>unwind</em>），默认的处理方式。Rust 会回溯栈上的数据和函数调用，终止出错所在线程，并调用析构函数。栈展开可以设置 RUST_BACKTRACE 环境变量来得到 backtrace。在没有使用 unsafe 代码的情况下，栈展开能保证 panic 时不会导致内存不安全。<code>panic::catch_unwind</code> 用于捕捉栈展开方式下的 panic，但要求传递过来的闭包必须是 UnwindSafe 的。若无标记，可以用 AssertUnWindSafe 这个包装器强制转换。</li>
<li>终止（<em>abort</em>）。程序会不清理数据直接退出，由操作系统来清理。可在配置项里配置 <code>panic = 'abort'</code>。</li>
</ul>
<p>用 <code>Option&lt;T&gt;</code> 表达可能为空的数据，它和 Result 一样可以在函数里里用 <code>?</code>  抛出。</p>
<p>如果要用到 <code>Option&lt;T&gt;</code> 的引用，一般来说 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6c7pZYP_iIE"><code>Option&lt;&amp;T&gt;</code> 比 <code>&amp;Option&lt;T&gt;</code> 更好</a>。</p>
<ul>
<li>若返回值里返回 Option 可变引用，<code>Option&lt;&amp;mut T&gt;</code>  和 <code>&amp;mut Option&lt;T&gt;</code> 语义不同，酌情选取。</li>
<li>若返回值里返回 Option 不可变引用，前者更优。从使用侧考虑，对 Option 做操作（如 map）时前者的变式更方便。此外在需求变化时，前者的兼容性也更好：当 <code>Option&lt;T&gt;</code> 改为 <code>Option&lt;Box&lt;T&gt;&gt;</code> 时，前者的函数签名不用变化；前者可以在函数里进一步 filter 而后者不行。</li>
<li>若参数里传入 Option 的可变引用，也是前者更优，因为后者在构造时会移动 T。</li>
</ul>
<p>前者的内存空间似乎比后者多了个标记位，但其实 Rust 做了 Option 套引用的内存优化，举例如下：</p>
<ul>
<li><code>Option&lt;i32&gt;</code> 会占用两个连续的字节，一个是标记位，一个存具体的 i32。</li>
<li><code>&amp;Option&lt;i32&gt;</code> 会占用一个固定的内存指针的空间，指向 <code>Option&lt;i32&gt;</code> 的地址。</li>
<li><code>Option&lt;&amp;i32&gt;</code> 只需一个内存指针，不再需要标记位：全零地址表示 None，非全零地址指向 i32 地址。</li>
</ul>
<p>黑科技：<code>If let Some(a) = b</code> 可以写成 <code>for a in b</code>（但是不推荐）。</p>
<p>Option 和 Result 之间可以灵活转化，Rust 提供了很多类似流操作的 API。</p>
<h2 id="trait">trait</h2>
<p>trait 类似于其他语言的接口（<em>interfaces</em>），用来定义一系列函数的集合。任何类型都可以是 trait 的实例。</p>
<p>定义 trait 时可为函数实现默认方法。注意，无法从相同方法的重载实现中调用默认方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型时，可以用 <code>:</code> 指定要求实现的 trait，称为泛型约束（<em>trait bound</em>）。多个 trait 之间用 <code>+</code> 连接。函数参数中可以用 <code>impl</code> 简化声明，也可以用 <code>where</code> 语法把参数里的泛型约束更清晰地提取出来。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: <span class="keyword">impl</span> <span class="title class_">Summary</span>)</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary， U: Summary&gt;(item1: T, item2: U)</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait 没有继承功能，但可以要求作为若干个 trait 的超集，用 <code>:</code> 和 <code>+</code> 连接，例如 <code>trait Subtrait: Supertrait1 + Supertrait2</code>，那么实现 <code>Subtrait</code> 时必须同时实现前两个 trait。</p>
<p>如果参数或返回值只有在实现 trait 时才能确定，可以用 <code>type</code> 关键字定义关联类型（<em>associated types</em>）。关联类型和泛型很像，但是在实现 trait 时只需指定一次，不必在每一处声明泛型类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">food</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eat</span>(&amp;<span class="keyword">self</span>, _: <span class="keyword">Self</span>::Food);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">food</span> = Grass;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">eat</span>(&amp;<span class="keyword">self</span>, grass: Grass) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在关联类型定义中声明泛型参数，被称为泛型关联类型（<em>Generic Associated Types</em>，GAT）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">I</span>&lt;T&gt;: Add&lt;T, Output = <span class="keyword">Self</span>::I&lt;T&gt;&gt; <span class="keyword">where</span> T: Add&lt;T, Output = T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&lt;T: Calculator&gt; &#123;</span><br><span class="line">    data1: T::I&lt;<span class="type">i8</span>&gt;,</span><br><span class="line">    data2: T::I&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">B</span>&lt;T&gt; &#123; <span class="title function_ invoke__">Val</span>(T), <span class="literal">Err</span>&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt;&gt; Add&lt;T&gt; <span class="keyword">for</span> <span class="title class_">B</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = B&lt;T&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">Val</span>(val) =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">Val</span>(val + rhs),</span><br><span class="line">            <span class="keyword">Self</span>::<span class="literal">Err</span> =&gt; <span class="keyword">Self</span>::<span class="literal">Err</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 定义满足以下条件的 trait 被认为是<strong>对象安全</strong>（<em>object safe</em>）的：</p>
<ul>
<li>没有任何关联类型，也不包含泛型参数。</li>
<li>所有 super trait 均是对象安全的。</li>
<li>所有函数正好只有第一个参数是涉及 self 的。</li>
</ul>
<p>当我们希望使用一个 trait 的实例而不确定到底是哪种类型时，可以用 dyn trait 来实现动态绑定。常见的使用方法是 <code>&amp;dyn trait</code> 或 <code>Box&lt;dyn trait&gt;</code>。注意如果 dyn trait 用于非对象安全的 trait，会触发 rust 编译器的报错。可以用 <code>where Self: Sized</code> 来将未满足对象安全条件的函数排除在外（dyn trait 时就无法调用）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>(x: <span class="type">i32</span>) <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">animal_speak</span>(animal: &amp;<span class="keyword">dyn</span> Animal) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    animal.<span class="title function_ invoke__">noise</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust <strong>不允许为外部类型实现外部 trait</strong>，即只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。这个限制被称为孤儿规则（<em>orphan rule</em>），主要有两个目的：防止 crate 间的 trait 互相冲突；实现向前兼容，即不会因为依赖 crate 中 trait 实现的变化造成无法编译。</p>
<p>一个绕开孤儿规则的方法是使用 newtype 模式，对待实现 trait 的类型做一个简单的封装。如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当和 trait 的方法出现歧义时，可以用完全限定语法（<em>fully qualified syntax</em>）指定。 如果结构体 Human 定义了 <code>fly(&amp;self)</code> 方法，它又实现了带有 <code>fly(&amp;self)</code> 方法的 Pilot trait，<code>h.fly()</code> 默认使用前者， <code>Pilot::fly(h)</code> 指定使用后者；如果 <code>fly()</code> 方法里不带有 <code>&amp;self</code>，用 <code>&lt;Pilot as Human&gt;::fly()</code>  指定使用后者。</p>
<h2 id="所有权和生命周期">所有权和生命周期</h2>
<p>Rust 中的每一个值都有一个对应的所有者（<em>owner</em>）的变量。当变量离开其作用域时，值会被丢弃。</p>
<ul>
<li>对未实现 copy trait 的类型进行赋值或函数传参时所有权会转移（<em>move</em>），原变量不能再被使用。</li>
<li>对于结构体或元组等编译期间可以确定的复合类型，允许部分成员发生所有权的转移，其他成员仍然可以正常使用，但结构体整体不允许再被使用；而数组、Vec 不允许部分成员转移，因为编译器无法准确统计。</li>
</ul>
<p>Rust 用 <code>&amp;</code> 表示引用（<em>borrow</em>），不发生所有者的转移；用 <code>&amp;mut</code> 表示可变引用，可以改变值但是不发生所有者的转移。借用检查规定：一个值在同一个作用域内只能有一个可变引用或多个不可变引用。</p>
<p>Rust2018 引入非词法作用域生命周期（<a target="_blank" rel="noopener" href="https://rust-lang.github.io/rfcs/2094-nll.html"><em>Non-Lexical Lifetimes</em></a>，NLL）特性。如果某个引用在以后的代码中不再被使用，它会在最后一句相关的语句执行之后提前被消除。即以下代码能正确运行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure>
<p>数组元素的借用会使整体被标记成借用。为了对多个元素进行可变操作，有以下几种解决方案：</p>
<ul>
<li>使用循环或其他迭代结构，这样可以在不同迭代步骤的作用域中分别可变借用不同的元素。</li>
<li>使用切片的 <code>split_at_mut</code> 方法，可以获得指向数组不同部分的两个可变切片。</li>
<li>使用 <code>Cell</code> 或 <code>RefCell</code> 这种提供内部可变性的类型，但会造成一些运行时的开销。</li>
</ul>
<p>生命周期（<em>lifetime</em>）用于表示多个引用的泛型生命周期参数如何相互联系。生命周期参数本质用泛型来标注，参数以 <code>'</code> 开头，通常是较短的小写字母（如 <code>'a</code>）。返回值引用和某个参数引用如果有相同的标记，意味着其生命周期不得短于该参数。注意使用泛型参数时，生命周期参数始终在类型参数之前。</p>
<p>下面的例子暗示了 <code>longest</code> 返回的引用的生命周期与传入两个引用的较小者保持一致。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体的每个引用也要标注。下例暗示 <code>ImportantExcerpt</code>  实例不能比其 <code>part</code> 字段引用的字符串存在得更久。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123; part: first_sentence &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体方法里的引用也要标注。下例展示了两组（执行生命周期省略规则后）合法的方法标注示例。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>早期 Rust 要求每个引用都标注明确的生命周期，后来编译器会执行生命周期省略规则（<em>lifetime elision rules</em>）。Rust 有一条输入生命周期（<em>input lifetimes</em>）省略规则和两条输出生命周期（<em>output lifetimes</em>）省略规则。它会根据这三条规则对当前代码进行不完整推断，如果推断完后仍然残留未知生命周期的参数就会编译报错。</p>
<ol>
<li>默认每一个是引用的参数都有它自己默认的生命周期参数。</li>
<li>如果输入生命周期参数只有一种，那么它会被赋予给所有输出生命周期参数。</li>
<li>如果方法有多个输入生命周期参数且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>（说明是对象的方法），那么所有输出生命周期参数会被赋予 <code>self</code> 的生命周期。</li>
</ol>
<p>根据 RFC 599 和 RFC1156，Trait 的默认生命周期会被加上 <code>'static</code>，显式加上 <code>'_</code> 才能用于常规的省略规则。</p>
<p>静态生命周期用 <code>'static</code> 标注，其生命周期能够存活于整个程序期间。字符串字面量默认是静态生命周期。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Map-和-Iterator">Map 和 Iterator</h2>
<p><code>std::collections::HashMap</code> 比 <code>ahash::HashMap</code> 更慢但更（密码学）安全。</p>
<p>HashMap 的键和值的类型必须各自相同。</p>
<ul>
<li><code>.insert(key, value)</code>：插入一组元素，若存在则会覆盖。</li>
<li><code>.entry(key).or_insert(value)</code>：如果 key 不存在，就插入指定 value。返回 value 的可变索引。</li>
</ul>
<p>对于基本类型这种实现了 <code>copy trait</code> 的类型，其值会直接拷贝至 map，否则会转移所有权至 map。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器都实现了一个叫做 <code>Iterator</code> 的标准 trait，其定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>type Item</code> 和 <code>Self::Item</code> 定义了 trait 的关联类型（<em>associated type</em>），表示 next 返回的是元素的类型。</p>
<p>用 <code>v.iter()/iter_mul()/into_iter()</code> 获取 vector 对应的迭代器。后者会获取 vector 的所有权。</p>
<p><code>map</code> 能遍历（消费）迭代器并返回一个新迭代器，<code>sum/collect/filter</code> 等能获得迭代器所有权并消费它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">	.<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">	.<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">	.<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">	.<span class="title function_ invoke__">sum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包">闭包</h2>
<p>所谓闭包，就是能够捕获作用域里变量的匿名函数。</p>
<p>定义闭包时，<code>||</code> 里定义参数列表，后接 <code>&#123;&#125;</code> 定义函数体。函数参数和返回值的类型可以省略，根据第一次使用的情况自动推理。闭包和函数最大的不同是它可以自动捕捉作用域里的变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>
<p>编译器倾向于优先通过不可变借用来捕获外部变量，其次是可变借用，最后才是移动所有权。</p>
<p>在闭包参数前加上 <code>move</code> 关键词后，闭包会强制获取作用域里所需变量的所有权（copy trait 仍然是拷贝），一般用于跨线程数据传输。这种闭包在调用一次之后无法再次捕获作用域里的变量，所以只能被 <code>FnOnce()</code> 接受。</p>
<ul>
<li>当 move 闭包使用了数组元素，且数组元素不支持 copy trait：获取了整个数组的所有权。</li>
<li>当 move 闭包使用了结构体、元组、枚举的字段，且该字段不支持 copy  trait：如果该结构体未实现 drop trait，则捕获的是单个字段的所有权，否则是整个结构体的所有权。</li>
</ul>
<p>闭包作为函数参数时，可以用三种 trait 承接：</p>
<table>
<thead>
<tr>
<th>trait 名</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FnOnce(self)</code></td>
<td>只能调用一次。所有闭包都会实现 <code>FnOnce</code> trait。</td>
</tr>
<tr>
<td><code>FnMut(&amp;mut self)</code></td>
<td>可多次调用。获取作用域里变量的可变引用，生存期间外界无法获取引用</td>
</tr>
<tr>
<td><code>Fn(&amp;self)</code></td>
<td>可多次调用。获取作用域里变量的不可变引用，生存期间外界无法获取可变引用</td>
</tr>
</tbody>
</table>
<p>普通函数的 <code>fn</code> 无须捕获作用域里的变量，因此可以随时随地调用。函数指针可将函数作为参数，其同时实现了闭包的三个 trait。不捕获环境中的任何变量的闭包可以通过匹配签名的方式自动转化成函数指针。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, arg: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span> = |x: <span class="type">i32</span>| x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包返回引用类型的参数时，需要显式指定生命周期。</p>
<h2 id="智能指针">智能指针</h2>
<p>智能指针通常用结构体实现，通过实现 Deref trait 和 Drop trait 来做到自动引用和清理。</p>
<p>最简单的智能指针是 <code>Box&lt;T&gt;</code>，实际数据会被转移到堆上存储，栈上仅保留指针。内存布局取决于 T 本身：如果是 T 是 Sized 栈上就只需记录地址，如果是 Slice 栈上还需记录长度，如果是 dyn trait 栈上还需记录虚表指针。</p>
<p>Box 可以解决递归类型的问题（Rust 不允许直接递归定义结构体，因为这样就无法计算所需空间）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Box 会实现 Deref 实现自动解引用。对 Box 执行解引用时，会转移指针内部数据的所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Rc&lt;T&gt;</code> 是引用计数指针，支持多所有权机制。用 <code>Rc::clone</code> 克隆时计数器会加一，离开作用域计数器就减一，当计数值为 0 时数据会被清理。 注意 <code>Rc&lt;T&gt;</code> 仅支持多个部分 <strong>只读地</strong> 共享数据，否则会违反所有权规则。</p>
<p><code>Rc&lt;T&gt;</code> 可能会引起引用循环导致内存泄漏，因为只有当 <code>strong_count=0</code> 才会清理。可以调用 <code>Rc::downgrade</code> 创建 <code>Weak&lt;T&gt;</code> 。弱引用也会进行计数，区别在于 <code>weak_count</code> 无须计数为 0 就能使 <code>Rc&lt;T&gt;</code> 实例被清理。</p>
<p><code>Cow</code> 智能指针包含 Borrowed 和 Owned 两种类型，前者是对原始数据的引用，后者拥有所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Cow</span>&lt;<span class="symbol">&#x27;a</span>, B&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    B: <span class="symbol">&#x27;a</span> + <span class="built_in">ToOwned</span> + ?<span class="built_in">Sized</span>,</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Borrowed</span>(&amp;<span class="symbol">&#x27;a</span> B),</span><br><span class="line">    <span class="title function_ invoke__">Owned</span>(&lt;B <span class="keyword">as</span> <span class="built_in">ToOwned</span>&gt;::Owned),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cow 支持 clone-on-write 功能，在需要 Clone 时才进行 Clone。下面是官网的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">abs_all</span>(input: &amp;<span class="keyword">mut</span> Cow&lt;[<span class="type">i32</span>]&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = input[i];</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            input.<span class="title function_ invoke__">to_mut</span>()[i] = -v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No clone occurs because `input` doesn&#x27;t need to be mutated.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(&amp;slice[..]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone occurs because `input` needs to be mutated.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(&amp;slice[..]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// No clone occurs because `input` is already owned.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br></pre></td></tr></table></figure>
<p>还有个经典例子是 <code>B = str</code>。<code>Cow&lt;&amp;str&gt;</code> 一般用于函数的返回值，取决于是否对参数 <code>&amp;str</code> 做了修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Cow</span> &#123;</span><br><span class="line">	<span class="title function_ invoke__">Borrowed</span>(&amp;<span class="type">str</span>),</span><br><span class="line">	<span class="title function_ invoke__">Owned</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小课堂：<code>size_of::&lt;Cow&lt;str&gt;&gt;()</code> 在 Rust 版本里的变迁。</p>
<h2 id="Unsafe-和内部可变性">Unsafe 和内部可变性</h2>
<p>unsafe 关键字可以修饰函数、代码块、trait 定义和 impl 块。</p>
<ul>
<li>用 unsafe 修饰的 trait 在 impl 的时候必须也加上 unsafe，不能和 safe 的混合使用。</li>
<li>unsafe 函数以为这个函数在某些场景下安全、某些场景下不安全，其调用必须在 unsafe 上下文中。和其他语言交互的 ffi 函数 <code>extern &quot;C&quot;</code> 会被隐式地带上 unsafe 修饰。</li>
<li>unsafe block 指需要使用 unsafe 代码作为内部实现（且当前上下文已经满足安全条件），如解裸指针。</li>
</ul>
<p>内部可变性（<em>interior mutability</em>）是 Rust 的一个设计模式，需要用 <code>unsafe</code> 标记，以模糊可变性和借用规则。</p>
<p><code>UnsafeCell&lt;T&gt;</code> 提供了一种在不可变值内部进行修改的方法。不基于其开发的内部可变性都是未定义行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UnsafeCell</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">	value: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Cell&lt;T&gt;</code> 基于所有权转移提供内部可变性接口，内部直接基于 UnsafeCell 做了封装，不会导致 panic。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Cell</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">	value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: Cell&lt;<span class="type">u32</span>&gt; = Cell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);    </span><br><span class="line"><span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">get</span>(), <span class="number">5</span>);                <span class="comment">// 返回内部数据拷贝，需要 T:Copy</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">replace</span>(<span class="number">10</span>);                 <span class="comment">// 替换 Cell 里的数据，返回旧数据</span></span><br><span class="line">a.<span class="title function_ invoke__">set</span>(<span class="number">10</span>);                             <span class="comment">// 替换 Cell 里的数据，舍弃旧数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: Cell&lt;<span class="type">u32</span>&gt; = Cell::<span class="title function_ invoke__">new</span>(<span class="number">10</span>);     </span><br><span class="line">a.<span class="title function_ invoke__">swap</span>(&amp;b);                            <span class="comment">// 交换两个相同类型的 Cell 的数据</span></span><br></pre></td></tr></table></figure>
<p><code>RefCell&lt;T&gt;</code> 基于引用计数提供内部可变性接口，内部也基于 UnsafeCell 开发。</p>
<ul>
<li>它有 <code>borrow</code> 和 <code>borrow_mul</code> 两个方法，分别创建一个不可变借用和可变借用。任何时候仅能有多个不可变借用或者一个可变借用，这个检查从编译时推迟到运行时，违反会 panic。</li>
<li>内部维护计数器：初始值为 ；不可变借用时值 +1，释放时值 -1；可变借用时值直接置为 -1。</li>
<li>使用 <code>try_borrow()</code> 可尝试获取不可变借用，若内部计数器值为 -1 则返回 BorrowError。</li>
</ul>
<p>结合 <code>Rc</code> 和 <code>RefCell</code> 来拥有多个可变数据所有者，即 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">6</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">10</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;:?&#125;&quot;</span>, a); <span class="comment">// a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;:?&#125;&quot;</span>, b); <span class="comment">// b after = Cons(RefCell &#123; value: 6 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;:?&#125;&quot;</span>, c); <span class="comment">// c after = Cons(RefCell &#123; value: 10 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="裸指针">裸指针</h2>
<p>裸指针为基本原生类型，分 <code>*const T</code> 和 <code>*mut T</code> 表示是否能修改指向数据。</p>
<ul>
<li>没有生命周期，不会自动执行任何内存安全检查，不保证指向有效的内存。</li>
<li>不能实现任何自动清理功能（不能自动 drop）。注意 <code>*ptr = data</code> 会调用旧值的 drop。</li>
<li>允许为空，用 <code>ptr::NonNull&lt;T&gt;</code> 表示非空且协变的可变裸指针。</li>
<li>不支持隐式转换，需要用 <code>as</code> 关键字转换。</li>
<li>只能在 unsafe 上下文中解引用。</li>
</ul>
<p>裸指针的获取方式：直接获取、<code>Box::into_raw()</code>、<code>std::ptr::addr_of!()</code>、从 C 中传递。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_num</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_num_ptr</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;my_num;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_speed</span>: <span class="type">i32</span> = <span class="number">88</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_speed_ptr</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = &amp;<span class="keyword">mut</span> my_speed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_speed</span>: <span class="type">Box</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">88</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_speed</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = <span class="type">Box</span>::<span class="title function_ invoke__">into_raw</span>(my_speed);</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(my_speed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ptr 模块常用的安全抽象方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会按字节对齐的 T 的大小计算偏移量，内部没有做边界检查</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">offset</span>&lt;T&gt;(<span class="keyword">self</span>, count: <span class="type">isize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> T / *<span class="keyword">mut</span> T</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">add</span>&lt;T&gt;(<span class="keyword">self</span>, count: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> T / *<span class="keyword">mut</span> T</span><br><span class="line"><span class="comment">// 按位复制，复制位数为 count*size_of::&lt;T&gt;()</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">copy</span>&lt;T&gt;(src: *<span class="keyword">const</span> T, dst: *<span class="keyword">mut</span> T, count: <span class="type">usize</span>)</span><br><span class="line"><span class="comment">// 在不读取或 Drop 旧值的情况下覆盖内存位置；要求内存地址对 T 对齐，否则用 write_unaligned。</span></span><br><span class="line"><span class="comment">// 如果是敏感信息，建议用 std::ptr::write_volatile() 函数。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">write</span>&lt;T&gt;(dst: *<span class="keyword">mut</span> T, src: T)</span><br><span class="line"><span class="comment">// 和 write 类似，额外返回旧值。更推荐使用 std::mem::replace</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">replace</span>&lt;T&gt;(dst: *<span class="keyword">mut</span> T, src: T) <span class="punctuation">-&gt;</span> T</span><br><span class="line"><span class="comment">// 从指针指向内存读取一个值，但不改变所有权；要求内存地址对 T 对齐，否则用 read_unaligned。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">read</span>&lt;T&gt;(src: *<span class="keyword">const</span> T) <span class="punctuation">-&gt;</span> T</span><br><span class="line"><span class="comment">// 要求 x 和 y 都初始化且对 T 对齐，两者指向位置可能重叠。更推荐使用 std::mem::swap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">swap</span>&lt;T&gt;(x: *<span class="keyword">mut</span> T, y: *<span class="keyword">mut</span> T)</span><br></pre></td></tr></table></figure>
<h2 id="FFI">FFI</h2>
<p>FFI（<em>Foreign Function Interface</em>）是一种编程技术，允许在一个语言中调用另一个语言便携的函数。Rust 的 FFI 特点是安全和高效。Rust 提供了丰富的类型和抽象来安全地、无额外开销地处理 C 语言的数据和函数。</p>
<p>ABI（<em>Application Binary Interface</em>）定义了函数调用细节（包括参数传递、返回值和寄存器等），调用双方要同时遵守。Rust 中的 FFI 安全性主要依赖于正确的 ABI 和正确的类型转换：函数签名（参数类型、参数顺序和返回类型）需要完全一致；数据布局要保持一致，Rust 结构体用 <code>#[repr(C)]</code>  表示 C 布局；交互时对象的生命周期需要正确地手动管理；Rust 的 Panic 和 C++ 的异常是互相不兼容的，在 ABI 边界要处理好所有异常。</p>
<p>用 <code>extern &lt;abi&gt;</code> 声明 FFI 时的 ABI，常见的包括：</p>
<ul>
<li><code>Rust</code>：Rust 自身的函数，可以认为 <code>fn f()</code> 带有 <code>extern &quot;Rust&quot;</code>。</li>
<li><code>C</code>：与 C 交互的标准 ABI，<code>extern fn f()</code> 时的默认值。</li>
<li><code>stdcall</code>：部分与 Win32 强相关的与 C 交互的 ABI。</li>
<li><code>system</code>：一般等价于 <code>C</code>，在不同系统里自动转化（如 Win32 系统里相当于 <code>stdcall</code>）。</li>
</ul>
<p>类型对照表：</p>
<table>
<thead>
<tr>
<th>C 类型</th>
<th>Rust 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td><code>void *</code></td>
<td><code>*mut c_void</code></td>
</tr>
<tr>
<td><code>int8_t, uint8_t, int16_t, ..., uint64_t</code></td>
<td><code>i8, u8, i16, ..., u64</code></td>
</tr>
<tr>
<td><code>float, double</code></td>
<td><code>f32, f64</code></td>
</tr>
<tr>
<td><code>char, unsigned char, signed char</code></td>
<td><code>c_char, c_uchar, c_schar</code></td>
</tr>
<tr>
<td><code>(unsigned) short/int/long/long long</code></td>
<td><code>c_(u)short/int/long/longlong</code></td>
</tr>
<tr>
<td><code>size_t, ptrdiff_t</code></td>
<td><code>usize, isize</code></td>
</tr>
<tr>
<td><code>char *, const char *</code></td>
<td><code>*mut c_char, *const c_char</code></td>
</tr>
<tr>
<td><code>struct, union, enum</code></td>
<td><code>struct, union, enum/i32</code></td>
</tr>
</tbody>
</table>
<p>Rust 里的 <code>String</code> 和 <code>&amp;str</code> 表示一定有效的 UTF-8 字符串数据。</p>
<ul>
<li><code>ffi::CString</code> 用于表示传递给 C 的字符串，末尾带有 <code>\0</code>，对应的切片是 <code>CStr</code>。</li>
<li><code>ffi::OsString</code> 用于表示平台原生字符串类型，对应的切片是 <code>OsStr</code>：Windows 系统中是非零的 16 位值的任意序列，一般为 UTF-16；Unix 系统中由非零字节组成的 8 位值的任意序列，一般为 UTF-8。</li>
</ul>
<p>智能指针、宽指针和函数在 Rust 和 C 转换时需要和 <code>*mut c_void</code> 交互，可用 Box 中转。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">create_my_struct_for_c</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">mut</span> c_void &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">mu_struct</span> = MyStruct &#123; value &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">boxed</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(my_struct);</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">into_raw</span>(boxed) <span class="keyword">as</span> *<span class="keyword">mut</span> c_void</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_back_from_c</span>(closure: *<span class="keyword">mut</span> c_void) <span class="keyword">where</span> F: <span class="built_in">FnOnce</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure</span> = <span class="type">Box</span>&lt;F&gt; = <span class="keyword">unsafe</span> &#123; <span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(closure <span class="keyword">as</span> *<span class="keyword">mut</span> F) &#125;;</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MaybeUninit&lt;T&gt;</code> 是 Rust 标准库提供的结构，表示可能没有被初始化的内存，适合和 C 交互。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = MaybeUninit::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">uninit</span>();</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	x.<span class="title function_ invoke__">as_mut_ptr</span>().<span class="title function_ invoke__">write</span>(<span class="number">5</span>); <span class="comment">// 如果不执行这句话，会导致未定义行为。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x_init</span> = <span class="keyword">unsafe</span> &#123; x.<span class="title function_ invoke__">assume_init</span>(); &#125;; </span><br></pre></td></tr></table></figure>
<p><code>ManuallyDrop&lt;T&gt;</code> 是 Rust 标准库提供的包装类型，用于阻止其包装的类型 T 的析构函数的自动调用。</p>
<p><code>GlobalAlloc</code> 是 Rust 中用于自定义内存分配器的 trait，当前仅能全局替换所有类型的分配方式。</p>
<h2 id="内存布局">内存布局</h2>
<p>如果一个结构体实现了 Sized，就在编译时有了确定的大小和对齐量，可以使用 <code>std::mem::size_of()</code>  和 <code>std::mem::align_of()</code> 计算对应的类型大小和对齐量。用 <code>repr</code> 更换对齐方式。</p>
<ul>
<li><strong>结构体和元组</strong> 布局规则一致：对齐量等于所有成员中对齐量的最大值，成员之间可能会留空隙。</li>
<li><strong>枚举</strong> 的 Tag 固定占一个字节，占用空间是每个成员的布局最大值加上一字节（没有优化的情况下）。</li>
<li><strong>Option</strong> 类型有特殊的优化，可以用零值表示 None，从而压缩掉 Tag 的字节。</li>
</ul>
<table>
<thead>
<tr>
<th>repr 规则</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>Rust 默认排布风格，不保证成员的排列顺序和稳定性。</td>
</tr>
<tr>
<td><code>C</code></td>
<td>C 风格排布，无优化。成员有序，会根据对齐量填空隙，枚举类型是枚举值和 union 两段</td>
</tr>
<tr>
<td><code>packed(n)</code></td>
<td>在基本对齐规则上，将结构体的对齐量减少到 <code>n</code>，成员之间的间隙按新对齐量填充。</td>
</tr>
<tr>
<td><code>align(n)</code></td>
<td>在基本对齐规则上，保证结构体的对齐量至少是 <code>n</code>（<code>n</code> 是 2 的幂次）。</td>
</tr>
<tr>
<td><code>&lt;int_type&gt;</code></td>
<td>声明枚举类型的 tag 的存储类型</td>
</tr>
<tr>
<td><code>transparent</code></td>
<td>用于单成员的结构体/枚举，表明内外有相同的内存布局。</td>
</tr>
</tbody>
</table>
<p>Union 类型通常只用于和 C 交互，所有字段共享同一段存储，对某个字段的 mut 引用等价于对整个结构体。</p>
<p>Union 类型不能实现 Drop Drait，其内部的成员类型也不能，即其成员类型必须满足以下之一：实现了 Copy Trait 的类型，<code>&amp;T</code> 或者 <code>&amp;mut T</code> 类型，<code>ManuallyDrop&lt;T&gt;</code> 类型，以上类型组成的元组或数组类型。</p>
<p>对 Union 类型的成员变量 <strong>读操作</strong> 必须 unsafe，包括常见的模式匹配来读取。</p>
<h2 id="宏">宏</h2>
<p>宏（<em>macro</em>）分为 <strong>声明宏</strong>（<em>declarative macro</em>）和三种 <strong>过程宏</strong>（<em>procedural macro</em>）。</p>
<p>声明宏用于编写一些类 match 的表达式来生成代码，类似于 C 中的 <code>define</code>。以下是 <code>vec!</code> 简化后的声明宏。<code>#[macro_export]</code> 标注说明：只要将定义了宏的 crate 引入作用域，宏就应当是可用的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程宏</strong>（<em>procedural macros</em>）更像是函数，接收 Rust 代码作为输入，操作后产生另一些代码作为输出。过程宏分为自定义派生（<em>derive</em>）、类属性和类函数三种。</p>
<p>举个例子，我们希望实现一个自定义 derive 宏，使得只要在结构体定义前加上 <code>derive(HelloMacro)</code> 的标记，就能为结构体自动定义一个能够打印结构体名字的 trait 方法。</p>
<ul>
<li>当用户在一个结构体前指定了 <code>derive(HelloMacro)</code> 标记后，<code>hello_macro_derive</code> 会被调用。</li>
<li><code>syn::parse</code> 负责解析把 rust 代码解析成可操作的数据结构。若失败，会直接 panic。</li>
<li><code>impl_hello_macro()</code> 读入可操作的数据结构，转化成新代码的 TokenStream。<code>quote!</code> 宏可以让我们编写需要返回的 Rust 代码。最后的 <code>into()</code> 方法会将其从原来的中间表示（IR）转化成 <code>TokenStream</code>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">impl_hello_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类属性宏不仅可以为属性生成代码，还可以创建新的属性。类函数宏能比声明宏更灵活地操控函数。</p>
<h2 id="serde-和-serde-json">serde 和 serde_json</h2>
<p><a target="_blank" rel="noopener" href="https://serde.rs/">serde</a> 用于将 Rust 结构体序列化和反序列化，serde_json 则专注于和 Json 的交互。</p>
<p>作用在结构体某个字段上的常见标记：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[serde(rename = <span class="string">&quot;name&quot;</span>)]</span>    <span class="comment">// 将序列化和反序列化的名字重命名成 name</span></span><br><span class="line"><span class="meta">#[serde(rename(serialize = <span class="string">&quot;ser_name&quot;</span>, deserialize = <span class="string">&quot;de_name&quot;</span>))]</span></span><br><span class="line"><span class="meta">#[serde(default)]</span>            <span class="comment">// 若该字段未出现则调用类型的 Default 方法</span></span><br><span class="line"><span class="meta">#[serde(default = <span class="string">&quot;path&quot;</span>)]</span>   <span class="comment">// 若该字段未出现则调用 path 指向的函数</span></span><br><span class="line"><span class="meta">#[serde(borrow)]</span>             <span class="comment">// 执行 zero-copy 反序列化，经典场景是反序列化成 &amp;str</span></span><br><span class="line"><span class="meta">#[serde(skip)]</span>               <span class="comment">// 该字段跳过序列化和反序列化</span></span><br><span class="line"><span class="meta">#[serde(skip_deserializing)]</span> <span class="comment">// 默认调用 Default，也可以配合 default = &quot;path&quot;</span></span><br><span class="line"><span class="meta">#[serde(skip_skip_serializing_if = <span class="string">&quot;path&quot;</span>)]</span>  <span class="comment">// e.g. &quot;Option::is_none&quot;</span></span><br><span class="line"><span class="meta">#[serde(serialize_with = <span class="string">&quot;path&quot;</span>)]</span>    <span class="comment">// 指定该字段的序列化方法，要求不能已实现 Serialize</span></span><br><span class="line"><span class="meta">#[serde(deserialize_with = <span class="string">&quot;path&quot;</span>)]</span>  <span class="comment">// 指定该字段的反序列方法，要求不能已实现 Deserialize</span></span><br><span class="line"><span class="meta">#[serde(borrow)]</span>                     <span class="comment">// 从原始数据里 borrow 而非新建</span></span><br></pre></td></tr></table></figure>
<p>作用在结构体或 enum 外层的常见标记：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[serde(rename = <span class="string">&quot;name&quot;</span>)]</span>          <span class="comment">// 修改整个结构体/enum 的名字</span></span><br><span class="line"><span class="meta">#[serde(rename_all = <span class="string">&quot;...&quot;</span>)]</span>       <span class="comment">// lowercase, UPPERCASE, PascalCase, camelCase, snake_case, SCREAMING_SNAKE_CASE, kebab-case, SCREAMING-KEBAB-CASE</span></span><br><span class="line"><span class="meta">#[serde(rename_all(serialize = <span class="string">&quot;...&quot;</span>, deserialize = <span class="string">&quot;...&quot;</span>))]</span>)]</span><br><span class="line"><span class="meta">#[serde(deny_unknown_fields)]</span>      <span class="comment">// 遇到未知字段时会报错（暂不支持和 flatten 一起用）</span></span><br></pre></td></tr></table></figure>
<p>对于 <a target="_blank" rel="noopener" href="https://serde.rs/enum-representations.html">enum</a>，默认使用 externally tagged 进行解析，也就是把每种类型名作为 map 的 key 来解析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[serde(tag = <span class="string">&quot;type&quot;</span>)]</span>             <span class="comment">// internally tagged，类型名放在名为 type 的 key 下。</span></span><br><span class="line"><span class="meta">#[serde(tag = <span class="string">&quot;t&quot;</span>, content = <span class="string">&quot;c&quot;</span>)]</span> <span class="comment">// adjacently tagged，额外把成员内容放在 content 下。</span></span><br><span class="line"><span class="meta">#[serde(untagged)]</span>                 <span class="comment">// 不再序列化 enum 的类型，直接平铺每个成员的内容</span></span><br></pre></td></tr></table></figure>
<p>有一个关于 <code>&amp;str</code> 进行反序列化的坑。由于转化成 Rust 的 <code>&amp;str</code> 后长度缩小了，<code>str</code> 的表示失败会 unwrap。解决方法是全程使用 <code>String</code>。如果真的想优化内存，可以使用 <code>Cow&lt;&amp;str&gt;</code> + <code>#[serde(borrow)]</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(serde::Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    a: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line">serde_json::from_str::&lt;Foo&gt;(<span class="string">r#&quot;&#123;&quot;a&quot;:&quot;123&quot;&#125;&quot;#</span>).<span class="title function_ invoke__">unwrap</span>();      <span class="comment">// no problem</span></span><br><span class="line">serde_json::from_str::&lt;Foo&gt;(<span class="string">r#&quot;&#123;&quot;a&quot;:&quot;123\n&quot;&#125;&quot;#</span>).<span class="title function_ invoke__">unwrap</span>();    <span class="comment">// unwrap</span></span><br></pre></td></tr></table></figure>
<p>用 <code> serde_json::to_string</code> 对 struct 序列化时结果是唯一的，字段之间会按定义顺序排序。但是如果字段里有无序结构（如 HashMap），则不能保证序列化结果的唯一性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = json!(&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phones&quot;</span>: [<span class="string">&quot;110&quot;</span>, <span class="string">&quot;120&quot;</span>],</span><br><span class="line">&#125;)                                             <span class="comment">// Construct Value</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: Value = serde_json::<span class="title function_ invoke__">from_str</span>(data)?;    <span class="comment">// Json String -&gt; Value</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Persion = serde_json::<span class="title function_ invoke__">from_str</span>(data)?;  <span class="comment">// Json String -&gt; Struct</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = v2.<span class="title function_ invoke__">to_string</span>();                        <span class="comment">// Value -&gt; Json String</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">j</span> = serde_json::<span class="title function_ invoke__">to_string</span>(&amp;p)?;            <span class="comment">// Struct -&gt; Json String</span></span><br></pre></td></tr></table></figure>
<p>测试时，常常需要比较 <code>Value</code> 和某 rust 结构（String 或 Hashmap 等）。可以使用 <code>json!()</code> 包裹后者。</p>
<h2 id="Cargo-Insta">Cargo Insta</h2>
<p>Insta 库是 Rust 测试里比较好用的库，能够为结果生成类似快照的内容，系统性地管理测试的输出文件。当第一次测试或结果有更新时会生成 <code>.snap.new</code> 为后缀的文件，归档后会生成 <code>.snap</code> 为后缀的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assert_snapshot!()</span><br><span class="line">assert_debug_snapshot!()</span><br><span class="line">assert_yaml_snapshot!()</span><br><span class="line">assert_ron_snapshot!()</span><br><span class="line">assert_json_snapshot!()</span><br><span class="line">assert_compact_json_snapshot!()</span><br></pre></td></tr></table></figure>
<p>使用 <code>cargo install cargo-insta</code> 安装 insta 的命令行工具，便于管理 snapshots 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo-insta review                               <span class="comment"># review all pending snapshots</span></span><br><span class="line">cargo-insta review --snapshot [snapshotname]     <span class="comment"># review specific snapshot</span></span><br><span class="line">cargo-insta accept/reject                        <span class="comment"># accept or reject snapshot(s)</span></span><br><span class="line">cargo-insta pending-snapshorts                   <span class="comment"># list all pending snapshots</span></span><br><span class="line">cargo-insta <span class="built_in">test</span> --accept                        <span class="comment"># run tests and accept all snapshorts</span></span><br><span class="line">cargo-insta <span class="built_in">test</span> --accept-unseen                 <span class="comment"># run tests and accept new snapshorts</span></span><br></pre></td></tr></table></figure>
<p>Insta <code>glob!</code> 宏支持一次管理多个文件，用 <a target="_blank" rel="noopener" href="https://docs.rs/globset/latest/globset/">globset</a> 通配。生成的 snapshots 文件名字包含<code>test_file_path</code>，<code>test_function</code> 和 <code>input_path</code> 三部分，其中 <code>input_path</code> 会取所有读取的文件的 lcp 的后面部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line">glob!(<span class="string">&quot;inputs/*.txt&quot;</span>, |path| &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = fs::<span class="title function_ invoke__">read_to_string</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    assert_json_snapshot!(input.<span class="title function_ invoke__">to_uppercase</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="附录：常见-trait">附录：常见 trait</h2>
<table>
<thead>
<tr>
<th>常见 trait</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add/Sub/…</td>
<td>通过实现对 std::ops 里的运算符 trait，可以实现运算符的重载。</td>
</tr>
<tr>
<td>Clone</td>
<td>标记结构体是否能被整个复制。</td>
</tr>
<tr>
<td>Copy</td>
<td>Clone 超集。标记性质，表示类型可以按位复制，和 Drop trait 不能一起实现。已实现的类型包括：整型，布尔型，浮点型，字符型，成员已实现的元组或数组，不可变引用。</td>
</tr>
<tr>
<td>Display</td>
<td>定义当前类型如何支持 Formatter 来打印。实现了 Display 会自动实现 ToString。</td>
</tr>
<tr>
<td>Drop</td>
<td>定义方法 <code>drop()</code>，在对象离开作用域时自动调用。析构是有顺序的。</td>
</tr>
<tr>
<td>Deref</td>
<td>重载解引用运算符，使得调用 <code>*mb</code> 等价于调用 <code>*(mb.deref())</code>。</td>
</tr>
<tr>
<td><code>Into&lt;T&gt;</code></td>
<td>定义当前类型如何转化成类型 T。</td>
</tr>
<tr>
<td><code>From&lt;T&gt;</code></td>
<td>定义当前类型如何从类型 T 转化而来。实现了 From 会自动实现 Into。</td>
</tr>
<tr>
<td><code>TryInto&lt;T&gt;</code></td>
<td>定义当前类型如何转化成类型 T，返回结果是 Result。</td>
</tr>
<tr>
<td><code>TryFrom&lt;T&gt;</code></td>
<td>定义当前类型如何从类型 T 转化而来，返回结果是 Result。</td>
</tr>
<tr>
<td><code>FromStr&lt;T&gt;</code></td>
<td>定义如何从 str 类型转化成当前类型，实现后通过 <code>.parse()</code> 触发。</td>
</tr>
<tr>
<td>Eq</td>
<td>PartialEq 超集，比较同类型的实例，要求满足自反性、对称性和传递性。</td>
</tr>
<tr>
<td>Ord</td>
<td>PartialOrd 和 Eq 超集，比较同类型的实例，要求比较顺序确定（浮点数未实现 Ord）</td>
</tr>
<tr>
<td>PartialEq</td>
<td>比较类型 A 的实例 a 是否和类型 B 的实例 b 是否相同。</td>
</tr>
<tr>
<td>PartialOrd</td>
<td>PartialEq 超集，比较类型 A 的实例 a 和类型 B 的实例 b 的大小关系。</td>
</tr>
<tr>
<td>Send</td>
<td>标记该类型能安全地发送至另一个线程</td>
</tr>
<tr>
<td>Sized</td>
<td>表示实例占用的空间大小在编译时确定。函数参数要求必须是 Sized。无长度的参数数组、不含 Sized 约束的 dyn  trait 和含有 ?Sized 约束的结构体泛型参数被认为是 Unsized 的。</td>
</tr>
<tr>
<td>Sync</td>
<td>标记该类型能够安全地在线程之间共享</td>
</tr>
<tr>
<td>ToString</td>
<td>定义当前类型如何转化成 String 类型，实现后通过 <code>.to_string()</code> 触发。</td>
</tr>
<tr>
<td>Unpin</td>
<td>表示类型能够安全地在内存中移动</td>
</tr>
<tr>
<td>UnwindSafe</td>
<td>标记发生 panic 时的类型是否仍然安全。</td>
</tr>
</tbody>
</table>
<h3 id="Sized">Sized</h3>
<p>动态大小类型（<em>dynamically sized types</em>，DST）允许我们处理只有在运行时才知道大小的类型。Rust 不允许直接创建 DST 的变量，也不能直接获取 DST 的参数。<code>str</code> 就是一个典型的 DST，我们常用引用的形式使用它（记录地址和长度，所以 <code>&amp;str</code> 的大小是 <code>usize</code> 大小的两倍），或者用 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code> 等指针使用它。</p>
<p>为了处理 DST，Rust 有一个特定的 trait <code>Sized</code> 来确定一个类型的大小是否在编译时可知。而且 Rust 隐式地为每一个泛型函数增加了 <code>Sized</code> bound。只有当 <code>T</code> 使用了 <code>T: ?Sized</code> 时才表明 <code>T</code> 的大小可能在编译时无法确定。</p>
<h3 id="Drop">Drop</h3>
<p>Rust 不允许自发调用 <code>Drop::drop</code> 方法，只能通过 <code>std::mem::drop(x)</code> 显式释放资源。析构顺序如下：</p>
<ul>
<li>作用域里的变量按定义的逆序析构，函数参数同样按定义的逆序析构。</li>
<li>嵌套的作用域按深度优先的顺序（<em>inside-out order</em>）析构。</li>
<li>结构体、枚举的字段按代码中声明的顺序析构，元组和数组按元素的先后顺序析构。</li>
<li>注意闭包通过移动捕获的变量的析构顺序目前是未定义的。</li>
</ul>
<h3 id="Deref">Deref</h3>
<p>如果没有实现 Deref trait，编译器只会解引用 &amp; 引用类型。deref 方法提供了其他解引用场景的功能。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?<span class="built_in">Sized</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 支持以下三种解引用的强制转换（<em>deref coercions</em>），如 <code>&amp;String</code> 能够强转为 <code>&amp;str</code>。</p>
<ul>
<li><code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li>
</ul>
<h3 id="Pin-和-UnPin">Pin 和 UnPin</h3>
<p>参考资料：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/pin/index.html">Pin Module</a>，<a target="_blank" rel="noopener" href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">Pin-Rust Async Book </a></p>
<p><code>Unpin</code> 是一种 trait，表示类型能够安全地在内存中移动。Rust 的类型默认会加上 <code>Unpin</code> 这个 trait，所以标准库中绝大部分类型都是 <code>Unpin</code> 的。异步编程里 <code>async/await</code> 产生的 <code>Future</code> 类是典型的 <code>!Unpin</code>。</p>
<p><code>Pin&lt;P&gt;</code> 是一种包裹类，意为 <code>P</code> 指向的地址 <code>T</code> 不会发生移动，常用来解决自引用的场景。注意只有当  <code>T:!Unpin</code> 时 <code>Pin&lt;P&gt;</code> 的功能才生效，即对 <code>Unpin</code> 的类型套上 <code>Pin</code> 后依然能正常将其移动。</p>
<p><code>Pin</code> 的实现原理可从源码中窥得一二。简单来说，<code>Pin</code> 占有了 <code>P</code> 指向地址的可变引用，外界只能通过 <code>unsafe</code> 的方式改变/移动它。如果我们通过把 <code>Pin&lt;&amp;mut T&gt;.as_mut()</code> 传入 <code>std::mem::swap(a, b)</code>  来尝试移动呢？注意到 <code>Pin</code> 不允许 <code>!Unpin</code> 结构进行 <code>get_mut()</code>，而 <code>as_mut()</code> 的返回结果也被包裹成  <code>Pin</code>，所以编译不通过。从源码中也能看出，若 <code>T</code> 是 <code>Unpin</code> 类型，<code>Pin&lt;'a, T&gt;</code> 完全等价于 <code>&amp;'a mut T</code>，能正常进行移动。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;P&gt; Pin&lt;P&gt; <span class="keyword">where</span> P: Deref, &lt;P <span class="keyword">as</span> Deref&gt;::Target: Unpin</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(pointer: P) <span class="punctuation">-&gt;</span> Pin&lt;P&gt; </span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">into_inner</span>(pin: Pin&lt;P&gt;) <span class="punctuation">-&gt;</span> P</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; Pin&lt;P&gt; <span class="keyword">where</span> P: Deref</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">new_unchecked</span>(pointer: P) <span class="punctuation">-&gt;</span> Pin&lt;P&gt;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">as_ref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Pin&lt;&amp;&lt;P <span class="keyword">as</span> Deref&gt;::Target&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; Pin&lt;P&gt; <span class="keyword">where</span> P: DerefMut</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">as_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Pin&lt;&amp;<span class="keyword">mut</span> &lt;P <span class="keyword">as</span> Deref&gt;::Target&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; Pin&lt;P&gt; <span class="keyword">where</span> P: DerefMut, &lt;P <span class="keyword">as</span> Deref&gt;::Target: <span class="built_in">Sized</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: &lt;P <span class="keyword">as</span> Deref&gt;::Target) </span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; Pin&lt;&amp;<span class="symbol">&#x27;a</span> T&gt; <span class="keyword">where</span> T: ?<span class="built_in">Sized</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_ref</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T&gt; <span class="keyword">where</span> T: ?<span class="built_in">Sized</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T <span class="keyword">where</span> T: Unpin</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">get_unchecked_mut</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pin&lt;&amp;<span class="symbol">&#x27;static</span> T&gt; <span class="keyword">where</span> T: ?<span class="built_in">Sized</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">static_ref</span>(r: &amp;<span class="symbol">&#x27;static</span> T) <span class="punctuation">-&gt;</span> Pin&lt;&amp;<span class="symbol">&#x27;static</span> T&gt;</span><br></pre></td></tr></table></figure>
<p>如果想标记一个类型是 <code>!Unpin</code> 的，目前 stable 版本中只能添加 <code>std::marker::PhantomPinned</code> 来达成。</p>
<h3 id="Send-和-Sync">Send 和 Sync</h3>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><code>Send</code> 和 <code>Sync</code></a> 用来刻画结构体在多线程模型下的线程安全性的 trait，是 rust 语言层面提供的标记。</p>
<table>
<thead>
<tr>
<th>Trait 名</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Send</code></td>
<td>该类型能安全地发送至另一个线程</td>
</tr>
<tr>
<td><code>Sync</code></td>
<td>该类型能够安全地在线程之间共享</td>
</tr>
</tbody>
</table>
<p>两者的关系是： <code>T</code> 是 <code>Sync</code> 的当且仅当 <code>&amp;T</code> 是 <code>Send</code> 的。</p>
<ul>
<li>几乎所有基本类型（裸指针）都是 <code>Send</code> 和 <code>Sync</code> 的。</li>
<li><code>UnsafeCell</code> 不是 <code>Sync</code> 的，这也导致 <code>Cell</code> 和 <code>RefCell</code> 不是  <code>Sync</code> 的。</li>
<li><code>Rc</code> 既不是 <code>Send</code> 也不是 <code>Sync</code> 的，它本身就被设计成单线程下的多引用，多线程下对应模型是 <code>Arc</code>。</li>
</ul>
<p>这两个 trait 能自动推导：如果一个类型的所有成员都是 <code>Send</code> 或 <code>Sync</code> 的，那么它也是  <code>Send</code> 或 <code>Sync</code> 的。如果自行给类型标注 <code>Send</code> 或 <code>sync</code>，需要在前面加上 <code>unsafe</code> 标记。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://jiangshibiao.github.io">jiangshibiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://jiangshibiao.github.io/Rust/">https://jiangshibiao.github.io/Rust/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Digest/">Digest</a><a class="post-meta__tags" href="/tags/Rust/">Rust</a></div><div class="post-share"><div class="social-share" data-image="/../post_images/Rust.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>Sponsor</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/images/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Travel-Notes-of-Hengdian/" title="横店游记"><img class="cover" src="/../post_images/Hengdian.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">横店游记</div></div><div class="info-2"><div class="info-item-1">记录了 2021.9.19-9.20 在横店的旅程。</div></div></div></a><a class="pagination-related" href="/Docker/" title="Docker"><img class="cover" src="/../post_images/Docker.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Docker</div></div><div class="info-2"><div class="info-item-1">记录了 Docker 相关的工程知识。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ACM-From-Zero/" title="从零开始 ICPC"><img class="cover" src="/../post_images/Selected-Problems-from-ACM-ICPC.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-10-10</div><div class="info-item-2">从零开始 ICPC</div></div><div class="info-2"><div class="info-item-1">OI/ICPC 知识图和难度分级。</div></div></div></a><a class="pagination-related" href="/Elementary-Number-Theory/" title="初等数论"><img class="cover" src="/../post_images/Elementary-Number-Theory.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-01-29</div><div class="info-item-2">初等数论</div></div><div class="info-2"><div class="info-item-1">记录了我对初等数论的系统性学习。</div></div></div></a><a class="pagination-related" href="/Introduction-to-Cryptography/" title="密码学导论"><img class="cover" src="/../post_images/Cryptography-in-Engineering.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-07-23</div><div class="info-item-2">密码学导论</div></div><div class="info-2"><div class="info-item-1">本篇密码学导论主要有以下几个特征：概括性（用统一的风格，列举密码学里经典的概念、定理和算法）、准确性（总体风格不拘小节，每个细节力求准确无误）、应用性（重点关注应用）和持续性（想到哪就写到哪，持续修正和扩展）。</div></div></div></a><a class="pagination-related" href="/Java-Review/" title="Java 语法"><img class="cover" src="/../post_images/Java-Review.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-09-02</div><div class="info-item-2">Java 语法</div></div><div class="info-2"><div class="info-item-1">记录了我对 Java 语法的系统性学习。</div></div></div></a><a class="pagination-related" href="/Multi-Party-ECDSA-Threshold-Signatures/" title="多方计算之 ECDSA 门限签名"><img class="cover" src="/../post_images/Multi-Party-ECDSA-Threshold-Signatures.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-08-05</div><div class="info-item-2">多方计算之 ECDSA 门限签名</div></div><div class="info-2"><div class="info-item-1">本篇文章试图入坑多方计算，缓更。</div></div></div></a><a class="pagination-related" href="/Probability-and-Statistics/" title="概率论和数理统计"><img class="cover" src="/../post_images/Probability-and-Statistics.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2023-09-04</div><div class="info-item-2">概率论和数理统计</div></div><div class="info-2"><div class="info-item-1">记录了我对概率论和数理统计的系统性学习。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">jiangshibiao</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jiangshibiao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/jiangshibiao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jiangshibiao1999@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://u.wechat.com/MMOFXmMIbxx2LV_lVEow1EY" target="_blank" title="Weixin"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎提出任何有用的建议~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%92%8C%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90"><span class="toc-number">1.</span> <span class="toc-text">环境安装和资料推荐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">包管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">结构体和函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vec-%E5%92%8C-String"><span class="toc-number">7.</span> <span class="toc-text">Vec 和 String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">8.</span> <span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Option-%E5%92%8C-Result"><span class="toc-number">9.</span> <span class="toc-text">Option 和 Result</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait"><span class="toc-number">10.</span> <span class="toc-text">trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.</span> <span class="toc-text">所有权和生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E5%92%8C-Iterator"><span class="toc-number">12.</span> <span class="toc-text">Map 和 Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">13.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">14.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe-%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">15.</span> <span class="toc-text">Unsafe 和内部可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">16.</span> <span class="toc-text">裸指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FFI"><span class="toc-number">17.</span> <span class="toc-text">FFI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">18.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">19.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#serde-%E5%92%8C-serde-json"><span class="toc-number">20.</span> <span class="toc-text">serde 和 serde_json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cargo-Insta"><span class="toc-number">21.</span> <span class="toc-text">Cargo Insta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E5%B8%B8%E8%A7%81-trait"><span class="toc-number">22.</span> <span class="toc-text">附录：常见 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sized"><span class="toc-number">22.1.</span> <span class="toc-text">Sized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Drop"><span class="toc-number">22.2.</span> <span class="toc-text">Drop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deref"><span class="toc-number">22.3.</span> <span class="toc-text">Deref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pin-%E5%92%8C-UnPin"><span class="toc-number">22.4.</span> <span class="toc-text">Pin 和 UnPin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Send-%E5%92%8C-Sync"><span class="toc-number">22.5.</span> <span class="toc-text">Send 和 Sync</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Travel-Notes-of-Yangzhou/" title="景德镇游记"><img src="/../post_images/Travel-Notes-of-Yangzhou.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="景德镇游记"/></a><div class="content"><a class="title" href="/Travel-Notes-of-Yangzhou/" title="景德镇游记">景德镇游记</a><time datetime="2025-09-26T16:00:00.000Z" title="Updated 2025-09-27 2025-09-27T00:00:00+08:00">2025-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/HydroOJ-Development-Notes/" title="小白的 HydroOJ 二次开发手记"><img src="/../post_images/HydroOJ-Development-Notes.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小白的 HydroOJ 二次开发手记"/></a><div class="content"><a class="title" href="/HydroOJ-Development-Notes/" title="小白的 HydroOJ 二次开发手记">小白的 HydroOJ 二次开发手记</a><time datetime="2025-09-19T16:00:00.000Z" title="Updated 2025-09-20 2025-09-20T00:00:00+08:00">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Data-Mining/" title="《数据挖掘》知识整理"><img src="/../post_images/Data-Mining.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《数据挖掘》知识整理"/></a><div class="content"><a class="title" href="/Data-Mining/" title="《数据挖掘》知识整理">《数据挖掘》知识整理</a><time datetime="2025-09-18T16:00:00.000Z" title="Updated 2025-09-19 2025-09-19T00:00:00+08:00">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Use-Python-Gracefully/" title="优雅地使用 Python"><img src="/../post_images/Python-Programming.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优雅地使用 Python"/></a><div class="content"><a class="title" href="/Use-Python-Gracefully/" title="优雅地使用 Python">优雅地使用 Python</a><time datetime="2025-09-08T16:00:00.000Z" title="Updated 2025-09-09 2025-09-09T00:00:00+08:00">2025-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Large-Language-Models/" title="大模型调研"><img src="/../post_images/Large-Language-Models.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大模型调研"/></a><div class="content"><a class="title" href="/Large-Language-Models/" title="大模型调研">大模型调研</a><time datetime="2025-09-06T16:00:00.000Z" title="Updated 2025-09-07 2025-09-07T00:00:00+08:00">2025-09-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By jiangshibiao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="没找到任何数据" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>