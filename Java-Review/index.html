<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 语法 | Technology Comes First</title><meta name="author" content="jiangshibiao"><meta name="copyright" content="jiangshibiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录了我对 Java 语法的系统性学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 语法">
<meta property="og:url" content="https://jiangshibiao.github.io/Java-Review/index.html">
<meta property="og:site_name" content="Technology Comes First">
<meta property="og:description" content="记录了我对 Java 语法的系统性学习。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jiangshibiao.github.io/post_images/Java-Review.jpg">
<meta property="article:published_time" content="2021-08-22T08:20:20.000Z">
<meta property="article:modified_time" content="2021-09-01T16:00:00.000Z">
<meta property="article:author" content="jiangshibiao">
<meta property="article:tag" content="Digest">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangshibiao.github.io/post_images/Java-Review.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 语法",
  "url": "https://jiangshibiao.github.io/Java-Review/",
  "image": "https://jiangshibiao.github.io/post_images/Java-Review.jpg",
  "datePublished": "2021-08-22T08:20:20.000Z",
  "dateModified": "2021-09-01T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "jiangshibiao",
      "url": "https://jiangshibiao.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/mylogo.jpg"><link rel="canonical" href="https://jiangshibiao.github.io/Java-Review/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 语法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Technology Comes First" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/friendlink/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(../post_images/Java-Review.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Technology Comes First</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 语法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/friendlink/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java 语法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-22T08:20:20.000Z" title="Created 2021-08-22 2021-08-22T16:20:20+08:00">2021-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-01T16:00:00.000Z" title="Updated 2021-09-02 2021-09-02T00:00:00+08:00">2021-09-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Lang/">Lang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>43mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在华为云工作时，发现 Java 语言是一个不可或缺的技能，遂进行学习和整理。</p>
<p>本文总结自翁恺老师的课程《Java 应用技术》以及廖雪峰的 <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744">Java 教程</a>，文字和图片侵删。</p>
<span id="more"></span>
<h2 id="Introduction">Introduction</h2>
<p>Java 由 SUN 公司 James Gosling 首创，原名 Oak，最初是针对嵌入式引用。随着互联网的崛起，SUN 公司改造了 Oak，并在 1995 年以 Java 的名称发布。SUN 公司后被 Oracle 收购。</p>
<p>Java是将代码编译成一种“字节码”（类似于抽象的CPU指令），并针对不同平台编写虚拟机，负责加载字节码并执行。对于 java 开发者来说，就实现了“一次编写，到处运行”的效果。源文件 <code>*.java</code> 经过编译得到了字节码文件 <code>*.class</code> 后，就可以在虚拟机上运行。<code>javac</code> 就是编译命令，而 <code>java</code> 是执行命令。</p>
<p><img src="/Java-Review/layer.png" alt></p>
<h2 id="Basic-Grammar">Basic Grammar</h2>
<p>Java 总体分为基本类型和引用类型。引用类型有一种取值叫做 <code>null</code>。</p>
<p>Java 中 使用 <code>==</code> 会判段是否指向同一个内存地址，<code>A.equals(B)</code> 才是判断内容是否逻辑上相等。</p>
<p>字符（Character）和字符串（String）类型</p>
<ul>
<li><code>char</code> 按 Unicode 编码储存，占 2 字节。可以用 <code>\u</code>+十六进制来表示一个字符，如  <code>\u4e2d</code> 表示“中”。</li>
<li>和 <code>char</code> 不同，字符串类型 <code>String</code> 是引用类型，<strong>字符串内容不可变，但变量可以更换指向对象</strong>。</li>
<li><strong>字符</strong> 比较大小可以用 <code>&lt;&gt;</code>，但字符串比较必须用 <code>compareTo</code>（返回 <code>-1,0,1</code>）。</li>
<li>字符串结束处没有 <code>\0</code> 修饰符。有一个求长度的方法 <code>length()</code>。</li>
<li>如果用 <code>+ </code> 连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串再连接。</li>
<li><code>StringBuilder</code> 提供字符串的修改、拼接，线程不安全；而 <code>stringBuffer</code> 是线程安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String1.concat(string2) / string1 + string <span class="number">2</span>   <span class="comment">// 连接字符串</span></span><br><span class="line">String.charAt()                                <span class="comment">// 定位字符串某个位置</span></span><br><span class="line">String.format(<span class="string">&quot;description: %f %d&quot;</span>, f, d)      <span class="comment">// 格式化字符串</span></span><br><span class="line">String.valueOf(&lt;type_name&gt; &lt;var_name&gt;)         <span class="comment">// 把某个类型转化成字符串</span></span><br><span class="line">String.substring(st_index, end_index)          <span class="comment">// 求子串</span></span><br></pre></td></tr></table></figure>
<p>数组的定义和使用</p>
<ul>
<li>数组是引用类型，一旦创建后大小不可变。</li>
<li>新建一个 int 数组（默认值为 0）：<code>int[] a=new int[5];</code></li>
<li>新建数组并初始化：<code>int[] a=&#123;1,2,3,4,5&#125;;</code> 或  <code>int[] a=new int[]&#123;1,2,3,4,5&#125;;</code>。</li>
<li>如果提供了数组初始化操作，则不能定义维表达式，即 <code>int[] a=new int[5]&#123;1,2,3,4,5&#125;</code> 是错的。</li>
<li><code>int[] a; a=new int[5]</code> <strong>合法</strong> 但是 <code>int[] a; a=&#123;1,2,3,4,5&#125;;</code> <strong>不合法</strong>（该形式仅用于初始化）。</li>
<li>多维数组的每一维里可以不等长，非首维的维度可以动态初始化。可以 <code>int [][] arr = new int [5][]</code>，后续要使用时再 <code>arr[0] = new int[3]</code>，如果直接 <code>arr[0][1]=1</code> 会报错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] arr : ns) </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : arr) </span><br><span class="line">        ... </span><br><span class="line">Array.sort(ns[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>可以用里 for each 的方式遍历可迭代对象。若遍历元素是基本类型则不能修改，是引用类型则可以修改。</p>
<p>Final 关键词可以修饰类、方法和变量。</p>
<ul>
<li>修饰基本类型时，基本类型的值不能发生改变。编译器会默认它是常量并进行优化（如下）。</li>
<li>修饰引用类型时，引用类型的地址值不能改变（但该对象堆内存的值可以改变）。</li>
<li>修饰一个类时，表示它不能被继承。final 类的所有方法都被隐式加上 final，但是变量是正常的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello2&quot;</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> b + <span class="number">2</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> d + <span class="number">2</span>;</span><br><span class="line">System.out.println((a == c));   <span class="comment">// true</span></span><br><span class="line">System.out.println((a == e));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Java 里的 switch 和 C++ 一样具有穿透性。</p>
<ul>
<li>case 表达式既可以用字面值常量，也可以用 final 修饰且初始化过的变量。</li>
<li>case 支持 char，byte，int，short 和枚举类，JAVA7 起支持 String。</li>
<li>String 常量判相等时，先计算 hashCode 再比较（所以不支持 null）。</li>
<li>Java 12 开始有一个新语法，支持用 switch 给某个变量赋值，且不具有穿透性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;orange&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">        <span class="keyword">yield</span> code; <span class="comment">// switch 语句返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Class">Class</h2>
<p>类里可用 <code>this.&lt;member&gt;</code> 调用成员，也可以用 <code>this(&lt;parameters&gt;)</code> 调用该类的其它初始化方法。</p>
<p>每个类只能继承自一个类，不写的话默认继承 Object 类。Object 类拥有一些成员函数：</p>
<ul>
<li><code>hashCode()</code> ：默认情况下，每一个实例的哈希值都不一样（可视为它们的地址），也可以重载。</li>
<li>还包括 <code>toString(), clone(), getClass(), equals(), hashCode()</code> 等函数。</li>
</ul>
<p>类的任何构造方法里，第一行必须用 <code>super(...)</code> 调用父类的构造方法（如果没写默认加上 <code>super()</code>）。也可以用 <code>super.&lt;member&gt;</code> 指定调用父类的成员。<code>super</code> 可以嵌套。</p>
<p>可以用 <code>&lt;instance_name&gt; instanceof &lt;class_name&gt;</code> 判断一个实例是否属于一个类（或它的子类）。向上转型（upcasting）是允许且安全的，可以用它来实现动态绑定；向下转型（downcasting）可能会失败报错（只有当一个类先向上转型再转回来才能成功）。向下转型前可以先用 <code>instanceof </code> 来判断合法性，以规避报错。</p>
<p>Java 支持重载（overload）和重写（override）。前者方法名相同而参数不同，返回类型也可以相同或不同。后者必须参数相同且返回类型相同（如果返回类型不同会报错）；可以用 <code>@Override</code> 标记重写函数，编译器会在不合法时给出警告；<strong>如果父类方法的返回值如果是一个类，子类方法可返回该类的子类。</strong></p>
<p>如果不指定初值，引用类型、数值类型、布尔类型会被默认初始化成 <code>null</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 和 <code>false</code>。如果既指定初值又在构造方法里出现，会先调用前者。具体的初始化顺序为：<strong>父类静态块—&gt;子类静态块—&gt;父类非静态块—&gt;父类构造方法—&gt;子类非静态块—&gt;子类构造方法</strong>。前两步静态块在类的装载时完成，后续调用时不再执行。</p>
<p>用 <code>abstract</code> 定义抽象类，它不能有实例。没有字段、全是抽象方法的类可以改写为接口 <code>interface</code>。</p>
<ul>
<li>接口会在方法前默认加上 <code>public abstract</code>，且不支持静态方法。</li>
<li>接口会给所有变量隐式加上 <code>public static final</code>。</li>
<li>类只能继承自一个类，但可以实现多个接口。实现接口用关键字 <code>implements</code>。</li>
<li>接口也是数据类型，可以向上或者向下转型。接口继承接口仍需使用 <code>extends</code>。</li>
<li>可以在接口的方法前加上 <code>default</code>，这样实现它的类可以不具有这个方法。</li>
</ul>
<p>如果一个类定义在另一个类或方法的内部，它被成为嵌套类（Nested Class）。嵌套类分为内部类（Inner Class）、匿名类（Anonymous Class）和静态嵌套类（Static Nested Class）。</p>
<ul>
<li>内部类的实例不能单独存在，必须依附于一个外部类。外界定义实例：<code>new Outer().new Inner()</code>。</li>
<li>内部类可以调用外部类里包括 private 的所有方法，外部类也可以调用某个内部类实例的所有方法。</li>
<li>如果内部类想调用重名的外部类成员，使用 <code>&lt;outer_class&gt;.this.&lt;member&gt;</code>。</li>
<li>匿名类的用法和内部类一致，但它可以直接创建，不用关心类名。</li>
<li>静态嵌套类用 static 修饰，无法调用 <code>Outer.this</code>，但可以调用外部类的静态成员。</li>
</ul>
<p>Java 有四种类内成员的修饰符，相比 C++ 多了一个 default。</p>
<p><img src="/Java-Review/class.png" alt></p>
<h2 id="Exception-and-Logging">Exception and Logging</h2>
<p>Java 的异常用 Throwable 类表示，它分为 Error 和 Exception。</p>
<ul>
<li>Error 表示编译时期的错误或系统错误等严重错误，如 OutOfMemoryError，NoClassDefFoundError。</li>
<li>Exception 是程序本身可以处理的异常，应当被捕获并处理。它主要分为两类：
<ul>
<li>RuntimeException 及其子类：运行时错误，无法预先捕捉。</li>
<li>非 RuntimeException 类，包括 IOException，TimeOutException 等：在编译时就会检查。</li>
</ul>
</li>
</ul>
<p>对于非 RuntimeException 及其子类的 Exception，Java 规定需要强制捕获或做 throws 声明。</p>
<p><code>try...catch</code>  按顺序捕获异常，所以子类要写在父类后面。不管有无异常最后都要执行 <code>finally</code>，可省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以继承 Exception 类来自己定义异常，通常建议从 RuntimeException 派生。</p>
<p>在函数体里用 throw 抛出异常。可以在方法定义处用 throws 声明该方法可能会抛出哪些异常。覆写父类方法的子类方法只能抛出与原方法相同的异常或它的子类，也可以选择不抛出异常。</p>
<p>捕获子函数异常并想抛出新异常时，建议把原异常放在新异常的构造方法里，在顶层使用 <code>e.printStackTrace()</code> 就可以打印出异常的堆栈。用 <code>e.getMessage()</code> 和 <code>e.toString()</code> 可以获得当前异常的详细/简短描述。</p>
<p>可以使用 Java 内置的日志来打印一些异常信息。日志可以存档、按级别分类、屏蔽低级别的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Log4j 是一个非常流行的日志框架，可以用 xml 配置它的各种功能。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际开发时，往往使用 Commons Logging 来完成日志的输出。它会自动搜索 Log4j，如果不存在就使用 JDK 默认的 Logging。它由 6 个日志级别（FATAL，ERROR，WARNING，INFO，DEBUG，TRACE），默认 INFO。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Generic">Generic</h2>
<p>Java 编译器会把泛型的 T 视为 Object，并在需要的时候转型给用户。虚拟机在运行时感知不到泛型。</p>
<p>这种泛型实现方法被称为擦拭法（Type Erasure），它会带来以下一些局限。</p>
<ul>
<li>对基本类型（如 int）不能使用泛型，因为它必须继承自 Object（只能换成 Integer）。</li>
<li>对确切的泛型类型使用 <code>instanceof()</code> 或 <code>getClass()</code> 是无效的，因为本质上是 <code>container&lt;object&gt;</code>。</li>
<li>不能实例化某个泛型 T，因为实际执行的是 <code>new Object()</code>。可以传入确切类的 Class 来做到实例化。</li>
<li>要防止重复定义 Object 的方法，如泛型类里定义 <code>public boolean equals(T obj)</code> 会报错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">List &lt;Integer&gt;l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs <span class="keyword">instanceof</span> Collection&lt;String&gt;) &#123; ...&#125; <span class="comment">// 不合法</span></span><br><span class="line"><span class="comment">//Error: Cannot perform instanceof check against parameterized type Collection&lt;String&gt;. Use the form Collection&lt;?&gt; instead since further generic type information will be erased at runtime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T t)</span> &#123;<span class="keyword">return</span> <span class="built_in">this</span> == t;&#125;</span><br><span class="line">    <span class="comment">// 不合法，编译器会把 T 替换成 Object，并阻止最终会变成覆写的泛型定义；换个方法名即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把一对继承类应用在泛型里后，他们不再有继承关系，例如 <code>Pair&lt;Integer&gt;</code> 不是 <code>Pair&lt;Number&gt;</code> 的子类。</p>
<p>如果想要在方法的参数里同时接收  <code>Pair&lt;Integer&gt;</code> 和  <code>Pair&lt;Integer&gt;</code> 两者，有以下几种方法。</p>
<ol>
<li>使用 <code>pair&lt;T extends Number&gt;</code>，表示接受 Number 类及其所有子类（不包括后续继承者）。</li>
<li>使用 <code>Pair&lt;? extends Number&gt;</code>，表示接受 Number 类及其所有继承链上的类。这种 <code>?</code> 的技术被称为 Wildcards（通配），这个例子描述的是上界通配符（Upper Bounds Wildcards）。使用类似 <code>&lt;? extends Number&gt;</code> 通配符作为方法的参数时，本质上表示 <strong>可以读，不能写</strong>。
<ul>
<li>方法内部可以调用获取 <code>Number</code> 引用的方法，如 <code>Number n = obj.getFirst()</code>。</li>
<li>方法内部无法调用传入 <code>Number</code> 引用的方法（<code>null</code> 除外），如 <code>obj.setFirst(Number n)</code>。</li>
</ul>
</li>
<li>使用 <code>pair&lt;? super Integer&gt;</code>，表示接受 Integer 类及其所有祖先链上的类。作为参数 <strong>可以写，不能读</strong>。
<ul>
<li>方法内部可以调用传入 <code>Integer</code> 引用的方法，如 <code>obj.setFirst(Integer n)</code>。</li>
<li>方法内部无法调用获取 <code>Integer</code> 引用的方法（<code>Object</code> 除外），如 <code>Integer n = obj.getFirst()</code>。</li>
</ul>
</li>
<li>使用 <code>pair&lt;?&gt;</code>，它被称为无限通配符（Unbounded Wildcard Type）。它作为参数不能读也不能写，一般可以用 <code>&lt;T&gt;</code> 替换 。注意 ``pair&lt;?&gt;<code>是所有</code>Pair<T><code>的超类，所以可以承接</code>pair<T>` 起到安全向上转型。</T></T></li>
</ol>
<p><code>&lt;? extends Base&gt;</code> 能读不能写，<code>&lt;? super Integer&gt;</code> 能写不能读，所以 Collection 的 <code>copy</code> 这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i);</span><br><span class="line">        dest.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以继承自一个确切的泛型类。在这种情况下，子类可以获取父类的泛型类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt;&#123;&#125;    <span class="comment">// 希望得到具体的泛型类型 Integer</span></span><br><span class="line"></span><br><span class="line">Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line"><span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) t;</span><br><span class="line">    Type[] types = pt.getActualTypeArguments();</span><br><span class="line">    <span class="type">Type</span> <span class="variable">firstType</span> <span class="operator">=</span> types[<span class="number">0</span>];                  </span><br><span class="line">    Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">    System.out.println(typeClass);              <span class="comment">// 得到 Integer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reflection">Reflection</h2>
<p>JVM 会为每种加载的类 A 创建一个关于 Class 的实例，并在该实例中保存 A 的所有类信息，包括类名、包名、父类、实现的接口、所有字段和方法。JVM 能通过这种方式动态获得所有实例的类信息，即反射（Reflection）。</p>
<ul>
<li>用 <code>&lt;class_name&gt;.class</code> 或 <code>&lt;instance_name&gt;.getClasss()</code> 获取某个类/实例对应的 Class 实例。如果知道某个类的完整名字，还可以用 <code>Class.forName(&lt;package_name&gt;.&lt;class_name&gt;)</code> 获取。</li>
<li>Class 的实例可以用 <code>==</code> 作比较，只有所属类完全相同才返回 <code>true</code>（比 <code>isinstanceof</code> 更严格）。</li>
<li>一些常用的 Class 的成员函数：<code>getName(), getSimpleName(), isInterface(), getSuperclass()</code>。</li>
<li>我们可以根据某个类对应的 Class 实例，进一步提取它的字段或调用它的函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));          <span class="comment">// 获取某个字段（包括父类）</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>);            <span class="comment">// 获取某个字段（不包括父类）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal/isPublic/isStatic(m);                   <span class="comment">// 判断字段的类型</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">f</span> <span class="operator">=</span> stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class); <span class="comment">// 获取指定参数类型的方法</span></span><br><span class="line">Method.getName()/getReturnType()/getParameterTypes()/getModifiers()</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);                                   <span class="comment">// 加了这句话才能访问私有方法</span></span><br><span class="line">System.out.println(f.invoke(&lt;instance&gt;, &lt;parameters&gt;));  <span class="comment">// 调用某个类的方法</span></span><br><span class="line">System.out.println(f.invoke(<span class="literal">null</span>, &lt;parameters&gt;));        <span class="comment">// 调用某个类的静态方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class); <span class="comment">// 获取某个类的构造方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) c.newInstance(<span class="number">123</span>);               <span class="comment">// 调用某个类的构造方法</span></span><br></pre></td></tr></table></figure>
<p>反射还支持动态代理（Dynamic Proxy）机制，能够动态地为一个接口创造实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(),   <span class="comment">// 传入 ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;,    <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler);                       <span class="comment">// 传入处理调用方法的 InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collection">Collection</h2>
<p>翁恺老师在讲课时抨击了 Collection 的标准翻译，认为“集合”这个词和 Set 高度相关，建议翻译成“容器”。</p>
<p>Java 在 <code>java.util</code> 包提供了容器类，主要有 List，Set 和 Map 等。</p>
<p><img src="/Java-Review/collection.png" alt></p>
<p>容器的对象不能设为基本类型（所以容器里也支持放入 null）。容器可以用统一的迭代器来高效遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = &lt;collection&gt;.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String s : list) System.out.println(s);             <span class="comment">// 会自动翻译成上一种方式</span></span><br></pre></td></tr></table></figure>
<p>List 是一种有序列表，它本身是个接口，有 ArrayList 和 LinkedList 两种具体泛型，分别用数组和链表实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object e)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>                                    <span class="comment">// 返回元素索引，不存在输 -1。</span></span><br><span class="line">Object[] toArray()</span><br><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); list.add(<span class="literal">null</span>);  <span class="comment">// 因为用包裹类，支持 null。</span></span><br><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);                   <span class="comment">// 用这种初始化不能接受 null。</span></span><br></pre></td></tr></table></figure>
<p><code>contains</code> 和 <code>indexOf</code> 依赖 <code>equals()</code>，可以重载。Java 标准库已正确实现了 Integer，String 的相等比较。</p>
<p><code>Map&lt;K, V&gt; </code> 是一种键-值映射表，K 和 V 是两个泛型结构。Map 也是接口，具体有以下实现：</p>
<ul>
<li>
<p>HashMap 里存放的 key 不一定是原来的 key，用 <code>.equals()</code> 比较 key。此外，HashMap 通过 <code>hashCode()</code> 实现快速哈希定位。以上两个函数都可以重载（当然要保证后者返回真要是前者的必要条件）。</p>
</li>
<li>
<p>如果 key 的对象是 enum 类型，可以改用 EnumMap。它的使用和 HashMap 一样，用紧凑数组保存结果。</p>
</li>
<li>
<p>Properties 相当于 Map&lt;String, String&gt;，专门用来处理配置文件。在配置文件里写上若干 <code>A=B</code> 的参数设置，然后可以定义 Properties  把它们 <code>load()</code> 进来或者 <code>store()</code> 回去。</p>
</li>
<li>
<p>TreeMap 实现了 SortedMap 的接口，内部保证了 key 的有序性。对 key 的比较有两种方式：</p>
<ul>
<li>新建 TreeMap 时构造函数传入 <code>Comparator</code> 接口，其内部实现好 <code>compare</code> 方法（返回 -1/0/1）。</li>
<li>TreeMap 的 key 的类 implement 了 <code>Comparable</code> 接口，并在类里实现 <code>compareTo</code> 方法。</li>
</ul>
</li>
</ul>
<p>Map 的键集合是 <code>keySet()</code>，值集合 <code>values()</code>，键值对集合 <code>entrySet()</code>。map 的变化会动态附加在这些集合上。如果 map 有了修改但指向这些集合的 Iterator 继续移动是未定义行为。可以依靠这些集合来 for each。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>                                     <span class="comment">// 存在返回旧值，否则返回 null</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(K key)</span>                                              <span class="comment">// 不存在返回 null</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(V value)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; map)</span></span><br><span class="line">    </span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(&lt;path&gt;, StandardCharsets.UTF_8));</span><br><span class="line"><span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">interval</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(&lt;path&gt;), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set 是一个存储不重复的元素集合的接口。</p>
<ul>
<li>HashSet 是 HashMap 的简单封装，所以需要正确实现 <code>equals()</code> 和 <code>hashCode()</code> 方法。</li>
<li>TreeSet 继承了 SortedSet 接口，和 TreeMap 一样必须实现 Comparable 接口或传入 Comparator 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object e)</span></span><br></pre></td></tr></table></figure>
<p>Queue 是实现队列功能的接口。PriorityQueue 实现了 Queue 接口，提供优先队列功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E)</span>/<span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E)</span>                            <span class="comment">// 添加到队尾，失败返回 false</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">()</span>/E <span class="title function_">poll</span><span class="params">()</span>                                        <span class="comment">// 获取队首并将其删除</span></span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span>/E <span class="title function_">peek</span><span class="params">()</span>                                       <span class="comment">// 获取队首</span></span><br></pre></td></tr></table></figure>
<p>接口 Deque 继承并拓展了 Queue 接口，主要应用是 ArrayDeque 和  LinkedList。</p>
<p>Java 的 Stack 类继承自 Vector 接口。这个继承模式比较奇怪，因为 Vector 可以访问随机位置；且 Stack 并非接口，只能作为唯一父类继承，没有 Deque 方便。所以官方建议用 <code>Deque&lt;String&gt; stack = new LinkedList() / new ArrayList&lt;&gt;();</code> 来替代 Stack。建议只调用 <code>push()/pop()/peek()/empty()</code> 来模拟栈操作。</p>
<h2 id="Thread-and-Lock">Thread and Lock</h2>
<p>Java 会启动主线程来执行 main 函数。新定义的线程用 <code>t.start()</code> 启动。有两种定义方式：</p>
<ul>
<li>继承 Thread 类并覆写 <code>run()</code> 方法，然后新开一个实例 t。</li>
<li>新建一个 Thread 类实例并传入实现了 <code>Runnable()</code> 接口的类，接口里是 <code>run()</code> 方法。</li>
</ul>
<p>线程一共有六种状态：</p>
<ul>
<li>New：新创建的线程，尚未被 <code>start()</code> 激活执行；</li>
<li>Runnable：运行中的线程，正在执行 <code>run()</code> 方法的 Java 代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作（如 <code>join</code>）在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行 <code>sleep()</code> 方法正在计时等待；</li>
<li>Terminated：线程已终止，因为 <code>run()</code> 方法执行完毕。</li>
</ul>
<p>对于线程 t，用 <code>t.join()</code> 方法可以使当前线程一直处于 Waiting 直到 t 运行结束。</p>
<p>对于线程 t，用 <code>t.interrupt()</code> 方法来强制中断它。但如果 t 正处于 Waiting/Timed Waiting 状态，它会立即获得 InterruptedException 的异常。为了避免这个异常，我们可以用 <code>try...catch</code> 捕捉 t 中会导致等待的代码。</p>
<p>还有一种终端线程的方法是使用标志位。新线程内部开一个 <code>volatile boolean</code> 布尔量，初始化为真，并写个 <code>while</code> 语句在真时不断执行任务。主线程想切断它时直接修改标志位即可。</p>
<p>JVM 会等到所有线程结束后再退出。可能有个线程需要定时触发，但是没有线程可以来帮忙结束这个线程。这时候就可以用到守护线程（Daemon Thread），在新线程创建后用 <code>t.setDaemon(true);</code> 声明。JVM 其实是在所有非守护线程执行完毕后退出，所以守护线程可以专门用来负责没人管的线程。</p>
<p>并行情境下，有个 context 可能需要同一个线程共享，在方法链上传递下去会比较麻烦。可以用 ThreadLocal 来新建和保存这个 context，这样整个线程里都能共享。它本质上维护了一张全局的 Map&lt;Thread, Object&gt;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设要在整个线程里传递 user 实例</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 支持用 <code>synchronized(lock)&#123;...&#125;</code> 将一段话设置为原子操作。线程必须获得锁才能进入，结束后释放锁。也可以用 <code>synchronized</code> 修饰方法把整个方法变为同步代码块，加锁对象是当前类的 this。这种线程锁是可重入锁：同一个线程反复获取锁会 +1，每次退出会 -1，只有减到 0 时才真正释放锁。</p>
<p>只有在锁里才能使用 <code>wait()</code> 和 <code>notify()/notifyAll()</code>。前者会暂时释放锁并等待，直到另一个线程调用后者再取回锁。<code>nofity()</code> 每次只会“随机”地唤醒一个符合要求的线程，所以建议用 <code>notifyAll()</code>。</p>
<p>Java 5 引入了一个高级的并发处理包 <strong>concurrent</strong>，提供了更多更灵活的多线程方式。</p>
<p><code>java.util.concurrent.locks</code> 提供了重入锁 ReentrantLock，可以用来替代 synchronized。它是由 Java 代码实现而非 Java 底层语法，所以需要用 <code>try</code> 语句包起来，并在 <code>finally</code> 里释放锁。更高级的是，它可以用 <code>lock.tryLock(1, TimeUnit.SECONDS)</code> 表示尝试取锁并最多等待一秒（否则返回 false）来避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock 提供了 Condition 对象来实现 wait 和 notify 的功能。它必须从 Lock 实例里新建，这样才能绑定。它提供 <code>await/signal/signalAll</code> ，等价于 <code>wait/notify/notifyAll</code>。此外，还可以使用 <code>await(1, TimeUnit.SECOND)</code> 表示如果规定时间内没有线程唤醒自身，自身可以主动醒来，更为灵活。</p>
<p>ReentrantReadWriteLock 用来提供只需一个线程写入、允许多个线程读的机制。本质上它用到两个锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rlock</span> <span class="operator">=</span> rwlock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wlock</span> <span class="operator">=</span> rwlock.writeLock();</span><br></pre></td></tr></table></figure>
<p>Java 8 还引入了新的读写锁 StampedLock 来进一步提高并发性。它允许读时同时有写发生，并能修正结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX; y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>concurrent 包把 Java 的 Collection 类挨个重写成线程安全的形式，用法一样，但是性能要低很多。</p>
<table>
<thead>
<tr>
<th style="text-align:left">interface</th>
<th style="text-align:left">non-thread-safe</th>
<th style="text-align:left">thread-safe</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:left">ArrayList</td>
<td style="text-align:left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td style="text-align:left">Map</td>
<td style="text-align:left">HashMap</td>
<td style="text-align:left">ConcurrentHashMap</td>
</tr>
<tr>
<td style="text-align:left">Set</td>
<td style="text-align:left">HashSet / TreeSet</td>
<td style="text-align:left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td style="text-align:left">Queue</td>
<td style="text-align:left">ArrayDeque / LinkedList</td>
<td style="text-align:left">ArrayBlockingQueue / LinkedBlockingQueue</td>
</tr>
<tr>
<td style="text-align:left">Deque</td>
<td style="text-align:left">ArrayDeque / LinkedList</td>
<td style="text-align:left">LinkedBlockingDeque</td>
</tr>
</tbody>
</table>
<p>concurrent 包还提供了一组原子操作的封装类，位于 <code>java.util.concurrent.atomic</code>。Atomic 类通过乌索的方式实现线程安全，主要利用了 CAS 原理。以 AtomicInteger 为例，它有以下几个原子函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span>                           <span class="comment">// 增加值并返回新值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span>                              <span class="comment">// 加1后返回新值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>                                          <span class="comment">// 获取当前值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span>          <span class="comment">// 尝试把 e 设成 u，失败返回 false</span></span><br></pre></td></tr></table></figure>
<p>concurrent 包提供线程池服务来减少线程开关的开销。ExecutorService 接口表示线程池，它的常见方法如下：</p>
<ul>
<li><code>submit(t)</code>：提交一个需要开新线程的任务实例。</li>
<li><code>shutdown()</code>：等当前线程池任务运行结束后关闭线程池。</li>
<li><code>shutdownNow()</code>：强制停止正在执行的任务并关闭线程池。</li>
<li><code>awaitTermination()</code>：等待指定的时间让线程池关闭。</li>
</ul>
<p>常见的线程池对象在 Executors 类里提供，包括以下种类。</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池。新建时传入线程池大小。</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池。可以指定大小的上下界。</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>有些任务需要反复执行，可以用 ScheduledExecutorService 接受，用 Executors 类的 ScheduledThreadPool 创建对象。它可以用 <code>scheduleAtFixedRate</code> 和 <code>scheduleWithFixedDelay</code> 指定触发每个线程任务的频率。</p>
<p>concurrent 包还提供了类似 Runnable 接口的 Callable 接口，后者是个泛型，线程运行结束后可以返回一个值。ExecutorService 的 <code>submit()</code> 方法返回的类型是 Future 类，可以用 <code>get()</code> 来获取 Callable 的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();     <span class="comment">// 从Future获取异步执行返回的结果，可能阻塞</span></span><br><span class="line"><span class="type">boolean</span> future.isDone();          <span class="comment">// 判断是否执行完成</span></span><br></pre></td></tr></table></figure>
<p>Future 类读取结果时会阻塞，所以 Java 8 引入了 CompletableFuture 类。它能在异步任务结束或出错时分别回调某个对象的方法，所以主线程不再需要关心异步任务的执行情况。</p>
<h2 id="Annotation">Annotation</h2>
<p>注解（Annotation）是 Java 里放在源码的类、方法、字段、参数前的一种特殊的注释。</p>
<ul>
<li>有些注解供编译器使用，编译后不再起作用，如 <code>@Override</code> 和 <code>@SupperessWarnings</code>。</li>
<li>元注解（Meta Annotation）由 Java 提供，能为用户自定义的注解提供注解。比如 <code>@Target</code> 可以定义当前注解能够被用于源码的哪些位置；<code>@Retention</code> 定义了注解存在的生命周期（编译期间/Class文件期间/运行期间），默认是 Class 文件，而我们定义的注解一般用于运行期间；<code>@Repeatable</code> 定义了注解能否写多条；如果加了 <code>@Inherited</code> ，表示应用于该类的当前注解也会应用到它的子类上。</li>
<li>可以用反射机制来操作附加在某个对象上的注解，即对于 <code>Class/Field/Method/Constructor</code>，使用 <code>getAnnotation(Report.class)</code> 读取注解的具体内容，使用 <code>isAnnotationPresent</code> 判断是否存在。</li>
<li>用户也能自定义注解，如下面这个 <code>@Report</code>。建议把最常用的参数名取成 <code>value()</code>，使用时可省略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@report(&quot;my_val&quot;, type = 2, level = 1)</span>                      <span class="comment">// 使用时</span></span><br></pre></td></tr></table></figure>
<h2 id="JDBC">JDBC</h2>
<p>JDBC（ Java DataBase Connectivity）是 Java 程序访问数据库的标准接口。</p>
<p>JDBC 接口保证了 Java 程序用同一套数据库访问代码访问各种不同数据库的能力。JDBC 接口是通过 JDBC 驱动来实现真正对数据库的访问，而不同的数据库会有各自的 JDBC 驱动（往往由对应的数据库厂商提供）。</p>
<p>所谓 JDBC 驱动本质上是一个 jar 包。以 mysql 为例，我们添加一个 Maven 依赖即可使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>DriverManager</code> 提供的静态方法 <code>getConnection()</code>，它会自动扫描 classpath，找到所有的 JDBC 驱动，然后根据我们传入的 URL 自动挑选一个合适的驱动。JDBC 连接是一种昂贵的资源，使用后要及时 <code>close()</code>，所以我们一般使用 <code>try(resource)</code> 来自动释放 JDBC 连接。Connection 会提供 <code>createStatement()</code> 方法来创建一个Statement 对象，用于执行一个查询。然后执行 Statement 对象提供的 <code>executeQuery(&lt;sql_phrases&gt;)</code> 传入 SQL 语句。所有查询结果用结构 ResulSet 来接收，它可以不断 <code>next()</code> 获取下一条结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">JDBC_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">JDBC_USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">JDBC_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT id, grade, name, gender FROM students WHERE gender=1&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> rs.getLong(<span class="number">1</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">grade</span> <span class="operator">=</span> rs.getLong(<span class="number">2</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">3</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">gender</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于直接用 Statement 很容易遭到注入攻击， JDBC 提供 PreparedStatement 来规避这个风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">login</span><span class="params">(String name, String pass)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE login=? AND pass=?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">    ps.setObject(<span class="number">2</span>, pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询用 <code>ps.executeQuery()</code>，插入更新删除统一用 <code>ps.executeUpdate()</code>（只是SQL 语句不同）。</p>
<p>如果数据库的表设置了自增主键，在执行插入时可以获取它的值 <code>conn.prepareStatement(&lt;insert_phrase&gt;, Statement.RETURN_GENERATED_KEYS)</code>。这样返回值就是插入内容的对应自增主键的值。</p>
<p>JDBC 默认关闭事务（每次操作后默认都 commit），可以用 <code>conn.setAutoCommit(false)</code> 打开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    insert(); update(); delete();</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED)</code> 设置隔离级别。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Isolation Level</th>
<th style="text-align:left">Situation Occurs</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Read Uncommitted</td>
<td style="text-align:left">Dirty Read</td>
<td style="text-align:left">A transaction is allowed to read data from a row that has been modified by another running transaction and not yet committed.</td>
</tr>
<tr>
<td style="text-align:left">Read Committed</td>
<td style="text-align:left">Non Repeatable Read</td>
<td style="text-align:left">A row is retrieved twice and the values within the row may differ between reads, because of the commits of other transactions.</td>
</tr>
<tr>
<td style="text-align:left">Repeatable Read</td>
<td style="text-align:left">Phantom Read</td>
<td style="text-align:left">New rows are added or removed by another transaction to the records being read，which occurs when using WHERE.</td>
</tr>
<tr>
<td style="text-align:left">Serializable</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h2 id="Functional-and-Stream">Functional and Stream</h2>
<p>Java 8 开始支持 Lambda 表达式。单方法接口被称为函数式接口（FunctionalInterface）。接收函数式接口作为参数的时候，可以把实例化的匿名类改写为Lambda表达式，能大大简化代码。</p>
<p>Lambda 表达式可以自动推断返回值。如果只有 return 一句，还可以进一步省略大括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>
<p>Java 8 还引入了一个全新的流式 API：Stream API。它位于 <code>java.util.stream</code> 包中。为了给基本类型加速（使用它们的包裹类会变慢），Java 还专门提供了 <code>IntStream, LongStream, DoubleStream</code>。</p>
<p>Stream 可以“存储“有限或无限个元素，元素在需要时实时计算。一个 Stream 可以轻易地转换为另一个 Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class="number">100</span>); <span class="comment">// 不计算</span></span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// 计算</span></span><br><span class="line">naturals.map(n -&gt; n.multiply(n)) <span class="comment">// 1, 4, 9, 16, 25...</span></span><br><span class="line">        .limit(<span class="number">100</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>Stream 可以手工创建，基于数组或 Collection 创建，或者基于 Supplier 创建（要实现 <code>get()</code> 函数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;);</span><br><span class="line">Stream&lt;String&gt; stream2 = List.of(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;Z&quot;</span>).stream();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NatualSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> <span class="title class_">NatualSupplier</span>());</span><br><span class="line">natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>有很多函数支持从一个 Stream 转换到另一个 Stream，或者对一个 Stream 做聚合。</p>
<ul>
<li><code>map()</code> 接收 Function 接口对象，里面定义了一个 <code>apply()</code> 方法，负责类型的转化。</li>
<li><code>filter()</code> 接收 Predicate 接口对象，里面定义了 <code>test()</code> 方法，负责判断元素是否符合条件。</li>
<li><code>reduce()</code> 是聚合函数，接收 BinaryOperator 接口对象，里面定义了 <code>apply()</code> 方法，负责把上一次累积的结果和本次元素进行运算并返回运算结果。</li>
<li><code>flatMap()</code> 会把 Stream 里的每个元素映射成 Stream，并把它们合并成一个新的。</li>
<li>静态方法 <code>concat()</code> 能把两个 Stream 合并成一个新的，<code>Stream.concat(s1, s2)</code></li>
<li><code>distinct()</code> 去重，<code>sorted()</code> 排序，<code>limit()</code> 截取，<code>skip()</code> 跳过，<code>parallel()</code> 并行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).map(n -&gt; n * n);</span><br><span class="line">List.of(<span class="string">&quot;  Apple &quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot; ORANGE&quot;</span>, <span class="string">&quot; BaNaNa &quot;</span>).stream().map(String::trim); <span class="comment">// 去空格</span></span><br><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).filter(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">opt = stream.reduce((acc, n) -&gt; acc + n);</span><br></pre></td></tr></table></figure>
<p>Stream 也可以输出或者转化为别的类型。</p>
<ul>
<li><code>.collect(Collectors.toList())</code> 可以转化 List 上，<code>collect(Collectors.toSet())</code> 转化到 Set。</li>
<li><code>.toArray(&lt;type&gt;[]::new)</code> 可以把 Stream 转化到数组。</li>
<li>还可以转化到 map 甚至分组输出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = stream.collect(Collectors.toMap(</span><br><span class="line">                        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">&#x27;:&#x27;</span>)),</span><br><span class="line">                        s -&gt; s.substring(s.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>)));</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; groups = list.stream().collect(Collectors.groupingBy(</span><br><span class="line">                 s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>), Collectors.toList()));</span><br></pre></td></tr></table></figure>
<h2 id="Design-Patterns">Design Patterns</h2>
<p>设计模式分为创建型模式、结构型模式和行为型模式。</p>
<p><strong>创建型模式</strong> 关注如何创建对象，其核心思想是把对象的创建和使用相分离，使得两者能相对独立地变换。</p>
<p>工厂方法（Factory Method）能使创建对象和使用对象分离，且客户端总是引用抽象工厂和抽象产品。这样允许创建产品的代码独立地变换，而不会影响到调用方。也可以直接把核心函数静态化调用，称为静态工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NumberFactory</span> &#123;</span><br><span class="line">    Number <span class="title function_">parse</span><span class="params">(String s)</span>;              <span class="comment">// 产品目标：从 String 转化成 Number</span></span><br><span class="line">    <span class="keyword">static</span> NumberFactory <span class="title function_">getFactory</span><span class="params">()</span> &#123;<span class="keyword">return</span> impl;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">NumberFactory</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberFactoryImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NumberFactory</span> <span class="variable">factory</span> <span class="operator">=</span> NumberFactory.getFactory();</span><br><span class="line"><span class="type">Number</span> <span class="variable">result</span> <span class="operator">=</span> factory.parse(<span class="string">&quot;123.456&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>抽象工厂模式（Abstract Factory）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。比如我们希望为用户提供 markdown 转化为 Html 和 Word 的业务，可以定义如下的抽象接口标准。最终某家供应商 SomeFactory 承担了功能实现，只需在创建时声明它，调用功能时和供应商是解耦的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    HtmlDocument <span class="title function_">createHtml</span><span class="params">(String md)</span>;  <span class="comment">// 需求1：创建 Html 文档</span></span><br><span class="line">    WordDocument <span class="title function_">createWord</span><span class="params">(String md)</span>;  <span class="comment">// 需求2：创建 Word 文档</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HtmlDocument</span> &#123;</span><br><span class="line">    String <span class="title function_">toHtml</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WordDocument</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HtmlDocument <span class="title function_">createHtml</span><span class="params">(String md)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FastHtmlDocument</span>(md);     <span class="comment">// 该具体实现由供应商提供</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> WordDocument <span class="title function_">createWord</span><span class="params">(String md)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FastWordDocument</span>(md);     <span class="comment">// 该具体实现由供应商提供</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AbstractFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeFactory</span>();   <span class="comment">// 创建时指定供应商</span></span><br><span class="line"><span class="type">HtmlDocument</span> <span class="variable">html</span> <span class="operator">=</span> factory.createHtml(<span class="string">&quot;#Hello\nHello, world!&quot;</span>);</span><br><span class="line">html.save(Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.html&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>原型模式（Prototype）是指创建新对象的时候，根据现有的一个原型来创建。</p>
<p>单例模式（Singleton）为了保证在一个进程中，某个类有且仅有一个实例。</p>
<p><strong>结构型模式</strong> 主要涉及如何组合各种对象以便获得更好、更灵活的结构。结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p>
<p>适配器模式（Adapter）用来作为两个不兼容的接口之间的桥梁。</p>
<p>桥接模式（Bridge）能将抽象部分与它的实现部分分离，使它们都可以独立地变化。例如，有三种品牌的汽车，每种汽车都可以配三种能源的发动机，直接继承会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 个类，且不利于进一步拓展汽车和发动机的种类。可以在汽车的公共抽象类 AbstractCar 里增加一个成员，它的类型是发动机的公共抽象类 Engine。这样，新建一个某发动机类型的某品牌汽车可以写成 <code>Abstract car = new SomeCar(new SomeEngine())</code>。</p>
<p>组合模式（Composite）常用于树形结构，使叶子对象和容器对象具有一致性来统一处理。</p>
<p>装饰器模式（Decorator）是一种在运行期动态给某个对象的实例增加功能的方法，在 Python 中有直接应用。</p>
<p>门面模式（Facade）能提供一个统一的接口去访问多个子系统的多个不同的接口，如 JVM 能在不同平台运行。</p>
<p>享元模式（Flyweight）的核心思想是：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<p>代理模式（Proxy）会通过代理对象访问目标对象，这样可以在目标对象实现的基础上扩展一定的功能。</p>
<p><strong>行为型模式</strong> 主要涉及算法和对象间的职责分配，描述一组对象应该如何协作来完成一个整体任务。</p>
<p>责任链模式（Chain of Responsibility）是一种把多个处理器组合在一起，依次处理请求的模式。我们可以把不同的 Handler（它们往往都实现了带有处理方法的接口）按顺序组装，对每个请求依次扫描责任链上的 Handler 并处理（有些变种是通过某个 Handler 手动调用下一个 Handler 来传递请求）。还有些责任链是由不同功能的 Handler 构成的，它们完成各自的工作，这种责任链也被称为拦截器（Interceptor）或者过滤器（Filter）。</p>
<p>命令模式（Command）会把每种请求封装成实现了统一接口的对应派生类。如文本编辑器需要支持复制、粘贴、删除等方法，而每个方法又涉及执行、撤销、回退等操作。可以设计一个带有 <code>execute, undo, redo</code> 的接口类，每新增一个字符串功能都继承该接口。命令模式能减少的是系统各组件的耦合度。</p>
<p>解释器模式（Interpreter）会针对特定问题设计一套专属解决方案，通过抽象语法树对用户输入的解释执行。例如数据库、正则表达式都是解释器模式，用户只要编写 SQL 语句、正则表达式语法即能正确使用引擎。</p>
<p>迭代器模式（Iterator）已经在 Java 的容器类中广泛使用了。它会提供一个统一的 Iterator 接口来遍历元素，保证调用者对集合内部的数据结构一无所知，从而使得调用者能以相同的接口遍历各种不同类型的集合。</p>
<p>中介模式（Mediator）又称调停者模式，它会引入中介者，把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
<p>备忘录模式（Memento）用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub），能让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。观察者可能有不同的类型，被观察者可以在设计时直接提供一个通用的观察接口，只要实现了该接口的观察者都能兼容地进行观察。</p>
<p>策略模式（Strategy）指在一个流程确定的方法中，某些步骤依赖调用方传入的参数，不同参数能带来不同功能。</p>
<p>模板方法（Template Method）指在设计某个类或算法时，把某些暂时确定不下来的步骤先写成抽象方法并正常调用给其他步骤，等子类继承后再补充这些抽象方法。</p>
<p>访问者模式（Visitor）能将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新操作。我们把访问者能访问的元素或者能执行的方法全都抽象进一个接口 Visitor（假设里面有两个方法 <code>readA()</code> 和 <code>readB()</code>）。为了实现访问者模式，不同数据结构会继承同一个带有 <code>accept(Visitor)</code> 方法的抽象类。类 A 在重写 <code>accept(Visitor)</code> 方法时可以执行 <code>Visitor.readA()</code> 而类 B 在重写时可以指定 <code>Visitor.readB()</code>。如果数据结构只有一个，Visitor 相当于是它的部分成员的友元类。</p>
<h2 id="Maven">Maven</h2>
<p>Apache Maven 最早属于 Jakarta Project 的一部分，后隶属于 Apache 基金会。</p>
<p>Maven 是一个主要提供给 Java 的自动化项目管理工具，拥有标准化的项目结构、构件流程和依赖管理。</p>
<p>Maven 默认的目录结构如下。源文件放在 <code>src/main/java</code>，测试文件在 <code>src/test/java</code>，资源文件放在 <code>resources</code>。项目描述文件是 <code>pom.xml</code>，编译、打包生成的文件放在 <code>target</code> 里。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br><span class="line"></span><br><span class="line">pom.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>groupId</code> 类似 java 的包名，<code>artifactId</code> 类似 java 的类名。groupId+artifactID+version 是项目唯一标识。</p>
<p>Maven 定义了几种关于包的依赖关系，用 <code>&lt;scope&gt;</code> 表示。</p>
<table>
<thead>
<tr>
<th style="text-align:left">scope</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">compile</td>
<td style="text-align:left">编译时需要用到该 jar 包（默认）</td>
<td style="text-align:left">commons-logging</td>
</tr>
<tr>
<td style="text-align:left">test</td>
<td style="text-align:left">编译 Test 时需要用到该 jar 包</td>
<td style="text-align:left">junit</td>
</tr>
<tr>
<td style="text-align:left">runtime</td>
<td style="text-align:left">编译时不需要，但运行时需要用到</td>
<td style="text-align:left">mysql</td>
</tr>
<tr>
<td style="text-align:left">provided</td>
<td style="text-align:left">编译时需要用到，但运行时由 JDK 或某个服务器提供</td>
<td style="text-align:left">servlet-api</td>
</tr>
</tbody>
</table>
<p>Maven 的生命周期（lifecycle）由一系列阶段（phrase）构成，内置的默认流程很长，包括 <code>clean-&gt;validate-&gt;...-&gt;compile-&gt;...-&gt;test-&gt;package-&gt;...-&gt;verify-&gt;install-&gt;deploy</code>。其中每个阶段可能有若干条目标（goal），目标都是按照 <code>&lt;phase_name&gt;:&lt;goal_name&gt;</code> 命名的，它是真正的执行阶段。</p>
<p>如果运行 <code>mvn package/compile</code>，会从头运行至对应阶段并停止。<code>mvn clean</code> 会清理所有生成的 class 和 jar，<code>mvn clean package/compile/test</code>  会先清理，然后从头运行至对应阶段。</p>
<p>Maven 通过调用各种插件（plugin）来执行相应的阶段。例如 <code>compiler</code> 服务于 <code>compile</code>， <code>surefire</code> 服务于 <code>test</code>，<code>jar</code> 服务于 <code>package</code>。一些常见的自定义插件有：</p>
<ul>
<li>maven-shade-plugin：打包所有依赖包并生成可执行 jar；</li>
<li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li>
<li>findbugs-maven-plugin：对 Java 源码进行静态分析以找出潜在问题。</li>
</ul>
<p>Maven 还支持模块的拆分，每个模块用单独的 <code>pom.xml</code> 维护，公共部分提取出来维护成 parent 的 <code>pom.xml</code>。最后在根目录创建一个统一编译的 <code>pom.xml</code>。每个阶段会把所有模块都跑一遍。</p>
<p>还有一个命令叫 <code>mvnw</code>，它是 Maven Wrapper 的缩写，能够为某个项目提供指定版本的 Maven。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://jiangshibiao.github.io">jiangshibiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://jiangshibiao.github.io/Java-Review/">https://jiangshibiao.github.io/Java-Review/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Digest/">Digest</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/../post_images/Java-Review.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>Sponsor</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/images/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Use-Git-Gracefully/" title="优雅地使用 Git"><img class="cover" src="/../post_images/Use-Git-Gracefully.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">优雅地使用 Git</div></div><div class="info-2"><div class="info-item-1">记录了我对 Git 的系统性学习。</div></div></div></a><a class="pagination-related" href="/Hexo-Butterfly/" title="Hexo-Butterfly 主题配置"><img class="cover" src="/../post_images/Hexo-Butterfly.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Hexo-Butterfly 主题配置</div></div><div class="info-2"><div class="info-item-1">记录了本博客采用的 Hexo/Butterfly 框架的部署配置。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ACM-From-Zero/" title="从零开始 ICPC"><img class="cover" src="/../post_images/Selected-Problems-from-ACM-ICPC.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-10-10</div><div class="info-item-2">从零开始 ICPC</div></div><div class="info-2"><div class="info-item-1">OI/ICPC 知识图和难度分级。</div></div></div></a><a class="pagination-related" href="/Elementary-Number-Theory/" title="初等数论"><img class="cover" src="/../post_images/Elementary-Number-Theory.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-01-29</div><div class="info-item-2">初等数论</div></div><div class="info-2"><div class="info-item-1">记录了我对初等数论的系统性学习。</div></div></div></a><a class="pagination-related" href="/Introduction-to-Cryptography/" title="密码学导论"><img class="cover" src="/../post_images/Cryptography-in-Engineering.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-07-23</div><div class="info-item-2">密码学导论</div></div><div class="info-2"><div class="info-item-1">本篇密码学导论主要有以下几个特征：概括性（用统一的风格，列举密码学里经典的概念、定理和算法）、准确性（总体风格不拘小节，每个细节力求准确无误）、应用性（重点关注应用）和持续性（想到哪就写到哪，持续修正和扩展）。</div></div></div></a><a class="pagination-related" href="/Multi-Party-ECDSA-Threshold-Signatures/" title="多方计算之 ECDSA 门限签名"><img class="cover" src="/../post_images/Multi-Party-ECDSA-Threshold-Signatures.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-07-18</div><div class="info-item-2">多方计算之 ECDSA 门限签名</div></div><div class="info-2"><div class="info-item-1">本篇文章试图入坑多方计算，缓更。</div></div></div></a><a class="pagination-related" href="/Probability-and-Statistics/" title="概率论和数理统计"><img class="cover" src="/../post_images/Probability-and-Statistics.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2023-09-04</div><div class="info-item-2">概率论和数理统计</div></div><div class="info-2"><div class="info-item-1">记录了我对概率论和数理统计的系统性学习。</div></div></div></a><a class="pagination-related" href="/Rust/" title="Rust 语法"><img class="cover" src="/../post_images/Rust.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-05-26</div><div class="info-item-2">Rust 语法</div></div><div class="info-2"><div class="info-item-1">记录了我对 Rust 语言的系统性学习。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">jiangshibiao</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jiangshibiao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/jiangshibiao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jiangshibiao1999@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://u.wechat.com/MMOFXmMIbxx2LV_lVEow1EY" target="_blank" title="Weixin"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎提出任何有用的建议~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Grammar"><span class="toc-number">2.</span> <span class="toc-text">Basic Grammar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-number">3.</span> <span class="toc-text">Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception-and-Logging"><span class="toc-number">4.</span> <span class="toc-text">Exception and Logging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generic"><span class="toc-number">5.</span> <span class="toc-text">Generic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflection"><span class="toc-number">6.</span> <span class="toc-text">Reflection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-number">7.</span> <span class="toc-text">Collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-and-Lock"><span class="toc-number">8.</span> <span class="toc-text">Thread and Lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Annotation"><span class="toc-number">9.</span> <span class="toc-text">Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC"><span class="toc-number">10.</span> <span class="toc-text">JDBC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functional-and-Stream"><span class="toc-number">11.</span> <span class="toc-text">Functional and Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Design-Patterns"><span class="toc-number">12.</span> <span class="toc-text">Design Patterns</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven"><span class="toc-number">13.</span> <span class="toc-text">Maven</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Board-Game-Light-Fun/" title="轻度桌游推荐"><img src="/images/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="轻度桌游推荐"/></a><div class="content"><a class="title" href="/Board-Game-Light-Fun/" title="轻度桌游推荐">轻度桌游推荐</a><time datetime="2025-07-22T16:00:00.000Z" title="Updated 2025-07-23 2025-07-23T00:00:00+08:00">2025-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Introduction-to-Cryptography/" title="密码学导论"><img src="/../post_images/Cryptography-in-Engineering.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="密码学导论"/></a><div class="content"><a class="title" href="/Introduction-to-Cryptography/" title="密码学导论">密码学导论</a><time datetime="2025-07-22T16:00:00.000Z" title="Updated 2025-07-23 2025-07-23T00:00:00+08:00">2025-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Exploring-DeepSeek/" title="探索 DeepSeek"><img src="/../post_images/DeepSeek.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="探索 DeepSeek"/></a><div class="content"><a class="title" href="/Exploring-DeepSeek/" title="探索 DeepSeek">探索 DeepSeek</a><time datetime="2025-07-20T16:00:00.000Z" title="Updated 2025-07-21 2025-07-21T00:00:00+08:00">2025-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Board-Game-Heavy-Strategy/" title="重度桌游推荐"><img src="/images/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重度桌游推荐"/></a><div class="content"><a class="title" href="/Board-Game-Heavy-Strategy/" title="重度桌游推荐">重度桌游推荐</a><time datetime="2025-07-19T16:00:00.000Z" title="Updated 2025-07-20 2025-07-20T00:00:00+08:00">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Multi-Party-ECDSA-Threshold-Signatures/" title="多方计算之 ECDSA 门限签名"><img src="/../post_images/Multi-Party-ECDSA-Threshold-Signatures.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多方计算之 ECDSA 门限签名"/></a><div class="content"><a class="title" href="/Multi-Party-ECDSA-Threshold-Signatures/" title="多方计算之 ECDSA 门限签名">多方计算之 ECDSA 门限签名</a><time datetime="2025-07-17T16:00:00.000Z" title="Updated 2025-07-18 2025-07-18T00:00:00+08:00">2025-07-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By jiangshibiao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="没找到任何数据" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>